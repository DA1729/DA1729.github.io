<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Need for Gadget Decomposition in LWE Based Cryptosystems | da1729&#39;s Blog</title>
  
  <!-- SEO Meta Tags -->
  <meta name="description" content="">
  <meta name="keywords" content="">
  <meta name="author" content="Daksh Pandey">
  
  <!-- Open Graph -->
  <meta property="og:title" content="Need for Gadget Decomposition in LWE Based Cryptosystems">
  <meta property="og:description" content="">
  <meta property="og:type" content="page">
  <meta property="og:url" content="/images/Need-for-Gadget-Decomposition-in-LWE-Based-Cryptosystems.html">
  <meta property="og:site_name" content="da1729&#39;s Blog">
  
  <!-- CSS -->
  
<link rel="stylesheet" href="/css/style.css">

  
  <!-- RSS Feed -->
  
  
  <!-- Favicon -->
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div class="page-wrapper">
    <!-- Header -->
    <header class="header">
      <h1>
        <a href="/" class="site-title">da1729&#39;s Blog</a>
      </h1>
      
        <p class="site-subtitle">cryptography, digital design, embedded, rf, ...</p>
      
      
      <!-- Navigation -->
      <nav class="nav">
        
          <a href="/" class="nav-link">Home</a>
        
          <a href="/quick" class="nav-link">Quick Posts</a>
        
          <a href="/archives" class="nav-link">Archives</a>
        
          <a href="/about" class="nav-link">About</a>
        
        
        <!-- Social Links -->
        
          
            <a href="https://github.com/DA1729" class="nav-link" target="_blank" rel="noopener">github</a>
          
            <a href="https://x.com/sp0oky_daksh" class="nav-link" target="_blank" rel="noopener">twitter</a>
          
            <a href="mailto:dakshpandey177@gmail.com" class="nav-link" target="_blank" rel="noopener">email</a>
          
            <a href="https://sp0oky-portfolio.vercel.app/" class="nav-link" target="_blank" rel="noopener">portfolio</a>
          
        
      </nav>
    </header>

    <!-- Main Content -->
    <div class="container">
      <div class="content">
        <main class="main-content">
          <!-- Static Page Template -->
<article class="article-card">
  <header class="article-header">
    <h1 class="article-title">Need for Gadget Decomposition in LWE Based Cryptosystems</h1>
    
    
      <div class="article-meta">
        <time datetime="2025-09-27T06:43:36.000Z">
          September 27, 2025
        </time>
        
          <span> • Updated: September 28, 2025</span>
        
      </div>
    
  </header>
  
  <div class="article-content">
    <div class="post-content">
      <p>Gadget Decomposition is one of the key and essential <strong>Homomorphic Operations</strong> in FHE cryptosystems based on the LWE problem. I have already introduced the LWE problem and how to build a basic cryptosystem around it in my previous blogs. In this blog, we will:</p>
<ol>
<li><strong>Extend</strong> the basic LWE cryptosystem into more generalized and mathematically robust cryptosystems</li>
<li><strong>Discuss</strong> a basic homomorphic operation: <strong>Ciphertext-Plaintext Multiplication</strong></li>
<li><strong>Introduce</strong> the <strong>Gadget Decomposition</strong> operation in the context of these generalized cryptosystems</li>
</ol>
<p>The information for this essential operation is quite scattered and inconsistent across the internet. I found it very confusing at first on how to implement the operation and, more importantly, when and where to apply it. I hope to clear this confusion with this blog. So let’s get into it.</p>
<hr>
<h2><span id="lwe-cryptosystem-quick-refresher">LWE Cryptosystem (Quick Refresher)</span></h2><p><strong>Setup</strong>: Secret key $\mathbf{s} \in {0, 1}^k$, scaling factor $\Delta &#x3D; \frac{q}{t}$ where $t \ll q$.</p>
<p><strong>Encryption</strong>: Given message $m \in \mathbb{Z}_t$, sample $\mathbf{a} \leftarrow \mathbb{Z}_q^k$ and $e \leftarrow \chi_\sigma$:<br>$$\boxed{\text{LWE}_{\mathbf{s}, \sigma}(\Delta m) &#x3D; (\mathbf{a}, b) \text{ where } b &#x3D; \mathbf{a} \cdot \mathbf{s} + \Delta m + e \pmod{q}}$$</p>
<p><strong>Decryption</strong>: Given ciphertext $(\mathbf{a}, b)$:<br>$$\boxed{m &#x3D; \left\lfloor \frac{b - \mathbf{a} \cdot \mathbf{s}}{\Delta} \right\rceil \bmod t}$$</p>
<hr>
<h3><span id="important-case-when-t-does-not-divide-q">Important Case: When $t$ Does Not Divide $q$</span></h3><p><em>This is a small detour from the original purpose of the blog, but it is an important and very critical detail of such cryptosystems.</em></p>
<p>In our previous analysis, we assumed that $t$ divides $q$. In this case, there is no upper or lower limit on the size of plaintext $m$: its value is allowed to wrap around modulo $t$ indefinitely, yet the decryption works correctly. This is because any $m$ value greater than $t$ will be correctly modulo-reduced by $t$ when we do modulo reduction by $q$ during decryption.</p>
<p>On the other hand, suppose that $t$ does not divide $q$. In such a case, we set the scaling factor as:<br>$$\Delta &#x3D; \left\lfloor \frac{q}{t} \right\rfloor$$</p>
<p>Then, provided $q \gg t$, the decryption works correctly even if $m$ is a large value that wraps around $t$. Let’s examine why this is so.</p>
<p>We can denote plaintext $m \bmod t$ as $m &#x3D; m’ + kt$, where $m’ \in \mathbb{Z}_t$ and $k$ is some integer representing the modulo $t$ wrap-around value portion of $m$. Setting the plaintext scaling factor as $\Delta &#x3D; \left\lfloor \frac{q}{t} \right\rfloor$, the noise-added scaled plaintext value becomes:</p>
<p>$$\left\lfloor \frac{q}{t} \right\rfloor \cdot m + e &#x3D; \left\lfloor \frac{q}{t} \right\rfloor \cdot m’ + \left\lfloor \frac{q}{t} \right\rfloor \cdot kt + e$$</p>
<p>By applying $m &#x3D; m’ + kt$:</p>
<p>$$&#x3D; \left\lfloor \frac{q}{t} \right\rfloor \cdot m’ + \frac{q}{t} \cdot kt - \left(\frac{q}{t} - \left\lfloor \frac{q}{t} \right\rfloor\right) \cdot kt + e$$</p>
<p>where $0 \leq \frac{q}{t} - \left\lfloor \frac{q}{t} \right\rfloor &lt; 1$:</p>
<p>$$&#x3D; \left\lfloor \frac{q}{t} \right\rfloor \cdot m’ + qk - \left(\frac{q}{t} - \left\lfloor \frac{q}{t} \right\rfloor\right) \cdot kt + e$$</p>
<p>We treat the above noisy scaled ciphertext as:<br>$$\left\lfloor \frac{q}{t} \right\rfloor \cdot m’ + qk - e’ + e$$</p>
<p>where $e’ &#x3D; kt$ is the maximum possible value of $\left(\frac{q}{t} - \left\lfloor \frac{q}{t} \right\rfloor\right) \cdot kt$. We overestimate the noise caused by this term to $kt$ because the maximum value this term can become is less than $kt$.</p>
<p>Given the LWE decryption relation $b - \mathbf{a} \cdot \mathbf{s} \bmod q &#x3D; \Delta m + e$, we can decrypt the above message by performing:</p>
<p>$$\left\lfloor \frac{1}{\left\lfloor \frac{q}{t} \right\rfloor} \cdot \left(\left\lfloor \frac{q}{t} \right\rfloor \cdot m’ + qk - kt + e \bmod q\right) \right\rceil \bmod t$$</p>
<p>$$&#x3D; \left\lfloor \frac{1}{\left\lfloor \frac{q}{t} \right\rfloor} \cdot \left(\left\lfloor \frac{q}{t} \right\rfloor \cdot m’ - kt + e\right) \right\rceil \bmod t$$</p>
<p>$$&#x3D; m’ - \left\lfloor \frac{kt + e}{\left\lfloor \frac{q}{t} \right\rfloor} \right\rceil \bmod t$$</p>
<p>$$&#x3D; m’ \quad \text{provided } \left\lfloor \frac{kt + e}{\left\lfloor \frac{q}{t} \right\rfloor} \right\rceil &lt; \frac{1}{2}$$</p>
<p><strong>Summary</strong>: If we set the plaintext’s scaling factor as $\Delta &#x3D; \left\lfloor \frac{q}{t} \right\rfloor$ where $t$ does not divide $q$, the decryption works correctly as long as the error bound $\left\lfloor \frac{kt + e}{\left\lfloor \frac{q}{t} \right\rfloor} \right\rceil &lt; \frac{1}{2}$ holds.</p>
<p>This error bound can break if:</p>
<ol>
<li>The noise $e$ is too large</li>
<li>The plaintext modulus $t$ is too large</li>
<li>The plaintext value wraps around $t$ too many times (i.e., $k$ is too large)</li>
</ol>
<p>A solution to ensure the error bound holds is that the ciphertext modulus $q$ is sufficiently large. In other words, if $q \gg t$, then the error bound will hold.</p>
<p>Therefore, we can generalize the formula for the plaintext’s scaling factor as $\Delta &#x3D; \left\lfloor \frac{q}{t} \right\rfloor$ where $t$ does not necessarily divide $q$.</p>
<hr>
<h2><span id="rlwe-cryptosystem-quick-refresher">RLWE Cryptosystem (Quick Refresher)</span></h2><p><em>I have discussed RLWE in detail in my previous blog, so this serves as a quick refresher.</em></p>
<p><strong>Setup</strong>: Work in polynomial ring $R]_{\langle n,q \rangle} &#x3D; \mathbb{Z}_q[x]&#x2F;(x^n + 1)$ with secret key $\mathbf{s} \stackrel{$}{\leftarrow} R_{\langle n,2 \rangle}$ and scaling factor $\Delta &#x3D; \frac{q}{t}$.</p>
<p><strong>Encryption</strong>: Given polynomial message $M \in R_{\langle n,t \rangle}$, sample $A \stackrel{$}{\leftarrow} R_{\langle n,q \rangle}$ and $E \stackrel{\chi_\sigma}{\leftarrow} R_{\langle n,q \rangle}$:<br>$$\boxed{\text{RLWE}_{\mathbf{s},\sigma}(\Delta M) &#x3D; (A, B) \text{ where } B &#x3D; A \cdot \mathbf{s} + \Delta M + E \pmod{R_{\langle n,q \rangle}}}$$</p>
<p><strong>Decryption</strong>: Given ciphertext $(A, B)$:<br>$$\boxed{M &#x3D; \left\lfloor \frac{B - A \cdot \mathbf{s}}{\Delta} \right\rceil \bmod t \in R_{\langle n,t \rangle}}$$</p>
<p><strong>Correctness</strong>: Requires noise bound $e_i &lt; \frac{\Delta}{2}$ for all coefficients $e_i$ of $E$.</p>
<hr>
<p><em>NOTE: All cryptosystems presented so far are symmetric (same key for encryption and decryption). The following section presents how to make such systems asymmetric.</em></p>
<h2><span id="glwe-cryptosystem-general-lwe">GLWE Cryptosystem (General LWE)</span></h2><p>As the name suggests, this is the generalized version of the LWE system that encompasses both LWE and RLWE. If you understand the construction of the two systems above, understanding this is straightforward.</p>
<p>First, we shall see the symmetric version, then I will present the asymmetric system, and this being the general version, one can easily map that system to the two systems above.</p>
<p><strong>Setup</strong>: Work in polynomial ring $R_{\langle n,q \rangle} &#x3D; \mathbb{Z}_q[x]&#x2F;(x^n + 1)$ with secret key list $\{S_i\}_{i&#x3D;0}^{k-1} \stackrel{$}{\leftarrow} R_{\langle n,2 \rangle}^k$ and scaling factor $\Delta &#x3D; \frac{q}{t}$.</p>
<p><strong>Encryption</strong>: Given polynomial message $M \in R_{\langle n,t \rangle}$, sample $\{A_i\}_{i&#x3D;0}^{k-1} \stackrel{$}{\leftarrow} R_{\langle n,q \rangle}^k$ and $E \stackrel{\chi_\sigma}{\leftarrow} R_{\langle n,q \rangle}$:<br>$$\boxed{\text{GLWE}_{S,\sigma}(\Delta M) &#x3D; (\{A_i\}_{i&#x3D;0}^{k-1}, B) \text{ where } B &#x3D; \sum_{i&#x3D;0}^{k-1}(A_i \cdot S_i) + \Delta M + E \pmod{R_{\langle n,q \rangle}}}$$</p>
<p><strong>Decryption</strong>: Given ciphertext $(\{A_i\}_{i&#x3D;0}^{k-1}, B)$:<br>$$\boxed{M &#x3D; \left\lfloor \frac{B - \sum_{i&#x3D;0}^{k-1}(A_i \cdot S_i)}{\Delta} \right\rceil \bmod t \in R_{\langle n,t \rangle}}$$</p>
<p><strong>Correctness</strong>: Requires noise bound $e_i &lt; \frac{\Delta}{2}$ for all coefficients $e_i$ of $E$.</p>
<p><strong>Connection to LWE&#x2F;RLWE</strong>:</p>
<ul>
<li>When $n&#x3D;1$ (polynomials become scalars), GLWE reduces to LWE</li>
<li>When $k&#x3D;1$ (single polynomial), GLWE reduces to RLWE</li>
</ul>
<hr>
<p>Now, let’s see the assymetric version. </p>
<h3><span id="public-key-glwe">Public-Key GLWE</span></h3><p>Ok, so the basic idea here, is that a part which is used during the encryption stage is pre-computed during the setup stage and released as the public-key. During the encryption stage, the encryptor will have to add some additional noise of theirs. Let’s see the mathematics of the system to make things more clear. </p>
<h4><span id="setup">Setup</span></h4><ul>
<li>The scaling factor: $ \Delta &#x3D; \lfloor \frac{q}{t} \rfloor $.</li>
<li>The secret key: $$\mathbf{S} &#x3D; \{S_i \}_{i &#x3D; 0}^{k - 1} \stackrel{$}{\leftarrow} R_{\langle n,2 \rangle}^k$$</li>
<li>Public key pair $(PK_1, \mathbf{PK_2}) \in R_{\langle n,q \rangle}^{k + 1}$ is to be generated as follows: $$ \mathbf{A} &#x3D; \{A_i\}_{i &#x3D; 0}^{k - 1} \stackrel{$}{\leftarrow}R_{\langle n,q \rangle}^{k} \text{,       } E \stackrel{\sigma}{\leftarrow}R_{\langle n,q \rangle}$$ $$\boxed{PK_1 &#x3D; \mathbf{A} \cdot \mathbf{S} + E \in R_{\langle n,q \rangle}}$$ $$\boxed{\mathbf{PK_2} &#x3D; \mathbf{A} \in R_{\langle n,q \rangle}^k}$$</li>
</ul>
<h4><span id="encryption">Encryption</span></h4><ul>
<li><p><strong>Input:</strong> $M \in R_{\langle n,t \rangle},  U \stackrel{$}{\leftarrow} R_{\langle n,2 \rangle},  E_1 \stackrel{$}{\leftarrow} R_{\langle n,q \rangle},  \mathbf{E_2} \stackrel{$}{\leftarrow} R^{k}_{\langle n,q \rangle}$</p>
</li>
<li><p>Scale up the plaintext message: $M \rightarrow \Delta M \in R_{\langle n,q \rangle}$.</p>
</li>
<li><p>Perform the following computations: $$B &#x3D; PK_1 \cdot U + \Delta M + E_1 \in R_{\langle n,q \rangle}$$ $$\mathbf{D} &#x3D; \mathbf{PK_2}\cdot U + \mathbf{E_2} \in R_{\langle n,q \rangle}^k$$</p>
</li>
<li><p>With the computations above, we get our final ciphertext: $$\boxed{\text{GLWE}_{S, \sigma}(\Delta M) &#x3D; (\mathbf{D}, B) \in R_{\langle n,q \rangle}^{k+1}}$$</p>
</li>
</ul>
<h4><span id="decryption">Decryption</span></h4><ul>
<li><strong>Input:</strong> A GLWE ciphertext $C &#x3D; (\mathbf{D}, B) \in R_{\langle n,q \rangle}^{k+1}$ and the secret key $\mathbf{S}$.</li>
<li>Cancel out the mask by computing the inner product with the secret key and subtracting it from $B$:<br>$$B - \mathbf{D} \cdot \mathbf{S} &#x3D; \Delta M + E_{all} \in R_{\langle n,q \rangle}$$ </li>
<li>Scale the result down by $\Delta$ and round to the nearest integer to remove the scaling factor and noise. This recovers the original plaintext message.$$\boxed{M’ &#x3D; \left\lfloor \frac{B - \mathbf{D} \cdot \mathbf{S}}{\Delta} \right\rceil \pmod t \in R_{\langle n,t \rangle}}$$</li>
<li><strong>Correctness Condition:</strong> For the decryption to be successful, every coefficient $e_i$ of the total noise polynomial $E_{all}$ must satisfy the condition $|e_i| &lt; \frac{\Delta}{2}$.</li>
</ul>
<h2><span id="glev-cryptosystem">GLev Cryptosystem</span></h2><p>GLev is a “leveled” homomorphic encryption scheme built upon GLWE. A GLev ciphertext isn’t a single entity, but rather a <strong>list of several GLWE ciphertexts</strong>. Each of these “level” ciphertexts encrypts the same underlying plaintext message, but uses a different, progressively smaller scaling factor. This structure is key for managing noise in homomorphic computations.</p>
<hr>
<ul>
<li><strong>Setup</strong>: In addition to the standard GLWE parameters ($n, q, t, k, \mathbf{S}$), GLev introduces two new ones:</li>
<li><strong>Decomposition Base</strong> $\beta$: An integer used to define the different scaling levels. It should be chosen such that $t &lt; \beta &lt; q$.</li>
<li><strong>Number of Levels</strong> $l$: The total number of GLWE ciphertexts that will make up a single GLev ciphertext.</li>
</ul>
<p>From these, a list of scaling factors is derived for each level $i \in [1, l]$:<br>$$\Delta_i &#x3D; \frac{q}{\beta^i}$$</p>
<p><strong>Encryption</strong>: To encrypt a message $M \in R_{\langle n,t \rangle}$, we generate $l$ separate public-key GLWE ciphertexts. The $i$-th ciphertext, $C_i$, encrypts the message $M$ using the scaling factor $\Delta_i$.</p>
<p>The complete GLev ciphertext is the collection of all these level ciphertexts:<br>$$\boxed{\text{GLev}_{S,\sigma}^{\beta,l}(M) &#x3D; { C_i &#x3D; \text{GLWE}_{S,\sigma}(\Delta_i M) }_{i&#x3D;1}^{l}}$$<br>where each ciphertext is $C_i &#x3D; (\mathbf{D}_i, B_i) \in R_{\langle n,q \rangle}^{k+1}$.</p>
<p><strong>Decryption</strong>: To decrypt a GLev ciphertext, you can choose to decrypt any specific level $i$. Decryption follows the standard GLWE procedure, but you <strong>must</strong> use the scaling factor $\Delta_i$ that corresponds to the level you are decrypting.</p>
<p>Given the $i$-th level ciphertext $C_i &#x3D; (\mathbf{D}_i, B_i)$:<br>$$\boxed{M’ &#x3D; \left\lfloor \frac{B_i - \mathbf{D}_i \cdot \mathbf{S}}{\Delta_i} \right\rceil \pmod t \in R_{\langle n,t \rangle}}$$</p>
<p><strong>Connection to Lev&#x2F;RLev</strong>: Just like GLWE, GLev is a generalized construction that unifies other schemes:</p>
<ul>
<li>When $n&#x3D;1$ (polynomials are scalars), GLev becomes the <strong>Lev</strong> cryptosystem.</li>
<li>When $k&#x3D;1$ (the secret key is a single polynomial), GLev becomes the <strong>RLev</strong> cryptosystem.</li>
</ul>
<p><em>NOTE: Keep this in mind, it’s gonna be the key concept later when I introduce the need for gadget decomposition.</em><br><em>Also, there is another generalization, i.e., the GGSW Cryptosystem, which is nothing but a list of GLev Ciphertexts, similar to how GLev is nothing but a list of GLWE ciphertexts, but GGSW is not required to fulfill the purpose of the blog, so I am gonna skip it. Curious people might refer to: <a target="_blank" rel="noopener" href="https://www.zama.ai/post/tfhe-deep-dive-part-1">TFHE Deep Dive</a> written by Ilaria Chillotti</em></p>
<h2><span id="homomorphic-operation-ct-pt-multiplication">Homomorphic Operation (<code>ct-pt multiplication</code>)</span></h2><p>I have made it clear in my previous blogs, that heart of all the modern FHE schemes is this LWE problem only, hence, the naive system which we built, i.e., GLWE system is obviously Fully Homomorphic. In fact, all of the core <strong>Homomorphic Operations</strong> and properties, can be demonstrated over this system, then be easily mapped over to specific schemes like TFHE, CKKS, etc. For this blog, I am not going over through all the operations. I will only present one operation, i.e., <strong>Ciphertext-Plaintext Multiplication</strong> which will guide us towards introducing <strong>gadget decomposition</strong>. So let’s dive right into it.</p>
<h3><span id="ciphertext-plaintext-multiplication">Ciphertext-Plaintext Multiplication</span></h3><p>Consider the GLWE ciphertext: $$C &#x3D; \text{GLWE}_{S, \sigma}(M) &#x3D; (A_1, \cdots , A_{k - 1}, B) \in R_{\langle n, q \rangle}^{k + 1}$$</p>
<p>Now, consider the following plaintext polynomial $\Phi$ : $$\Phi &#x3D; \sum_{i&#x3D;0}^{n-1}(\Phi_i \cdot X_i) \in R_{\langle n, q \rangle}$$</p>
<p>Now, if want to homomorphically multiply this plaintext to the ciphertext, such that after decrypting the resulting ciphertext, I should get the original plaintext message multiplied with the second plaintext message ($\Phi$). Note that we are never encrypting the second plaintext. Now it can be easily shown with very easy mathematics, that following is true: </p>
<p>$$ \Phi \cdot \text{GLWE}_{S, \sigma}(\Delta M) &#x3D; \Phi \cdot (\{A_i\}_{i &#x3D; 0}^{k - 1}, B) &#x3D; (\{\Phi \cdot A_{i}\}_{i &#x3D; 0}^{k - 1}, \Phi \cdot B) &#x3D; \text{GLWE}_{S, \sigma}(\Delta(M\cdot \Phi))$$</p>
<h2><span id="gadget-decomposition-for-limiting-noise-growth">Gadget Decomposition for Limiting Noise Growth</span></h2><p>If you would have done some easy calculations to verify the equation for (<code>ct-pt multiplication</code>), you must have noticed that the <strong>new error</strong> term is <strong>scaled-up</strong> by $|\Phi|$. Which can potentially be a huge problem, unless we have $t$ very very less compared to $q$, which is not always the case, and even if we were to increase $q$, the computational cost is gonna increase too much to even consider that, as we already have to take a big $q$, so increasing $q$ is not a sensible option, practically speaking. </p>
<p>The way we are going to tackle the problem, is that we will decompose our plaintext into a series of smaller moduli terms, then have <strong>separate ct-pt multiplied GLWE encryptions</strong> for each of those smaller moduli terms. Mathematically, the decomposition would look like this: $$\Phi &#x3D; \Phi_1\cdot \frac{q}{\beta^1} + \Phi_2\cdot \frac{q}{\beta^2} + \cdots + \Phi_l \cdot \frac{q}{\beta^l} \rightarrow \text{decomp}^{\beta, l}(\Phi) &#x3D; (\Phi_1, \cdots, \Phi_l)$$</p>
<p>Now, for the given GLWE ciphertext, we can get the following GLev ciphertext: $$ \text{GLev}^{\beta,l}_{S,\sigma}(\Delta M) &#x3D; \{ \text{GLWE}_{S,\sigma}(\Delta M \tfrac{q}{\beta^1}), \dots, \text{GLWE}_{S,\sigma}(\Delta M \tfrac{q}{\beta^l}) \} $$</p>
<p>Next, consider the operation below: $$ \text{decomp}^{\beta, l}(\Phi)\cdot \text{GLev}_{S, \sigma}^{\beta, l}(\Delta M)$$ $$&#x3D; \sum_{i&#x3D;1}^{l}(\Phi_i \cdot \text{GLWE}_{S, \sigma}(\frac{q}{\beta^i}\Delta M))$$ $$ &#x3D; \sum_{i&#x3D;1}^{l}(\text{GLWE}_{S, \sigma}(\frac{q}{\beta^i}\Delta M\cdot \Phi_i))$$ $$&#x3D; \text{GLWE}_{S, \sigma}(\sum_{i&#x3D;1}^{l}(\frac{q}{\beta^i}\Delta M\cdot \Phi_i))$$ $$ &#x3D; \text{GLWE}_{S, \sigma}(\Delta M\cdot\sum_{i &#x3D; 1}^{l}(\frac{q}{\beta^i}\cdot \Phi_i)) &#x3D; \text{GLWE}_{S, \sigma}(\Delta M \cdot \Phi)$$</p>
<h3><span id="why-not-base-decomposition">Why not Base Decomposition</span></h3><p>This proves that the evaluation is nothing but the ciphertext-multiplication only. I made one benefit of doing this <strong>gadget-decomposition</strong> earlier only by arguing that each resulting &#96;ct-pt multiplication has less noise growth compared to the original non-decomposed multiplication. But one question might be coming up in your minds, i.e., why gadget decomposition? We can also do a base decomposition, which is dividing the plaintext into uniform modulus components, that way we won’t have to worry about more noise growth in some components as compared to others as each resulting multiplication would have same resulting noise growth. </p>
<p>Base decomposition would obviously work with the benefit mentioned above, but for the cost of number of computations. See, when we decompose the plaintext among different gadgets across a base, we end up with lesser terms compared to decomposing them across the same base. Lesser terms imply less multiplication operations, and multiplication is not an easy elementary operation. </p>
<h3><span id="mathematics-behind-selection-of-beta">Mathematics behind selection of $\beta$</span></h3><p>Obviously, our main goal selecting $\beta$ should be that the resulting ciphertext doesn’t explode with noise. The main risk does not come from the individual multiplications, but rather when we accumulate the increased noise across the components. If each initial GLWE ciphertext in the GLev ciphertext which we considered has a noise polynomial $\Phi_i$, the final noise polynomial can be written as $$E_{\text{final}} &#x3D; \sum_{i &#x3D; 1}^l (\Phi_i \cdot E_i)$$</p>
<p>Now, keeping the largest absolute coefficient in this final noise polynomial smaller than half of the scaling factor, $\Delta$, should be enough to ensure that the resulting noise is well within the tolerable limit. For this I am just going to use the infinity-norm notation ($ \lVert \cdot \rVert_{\infty} $), which just gives us the largest absolute coefficient. So the goal is to satisfy: $$\lVert E_\text{final} \rVert_{\infty} &lt; \frac{\Delta}{2}$$</p>
<p>The plan now is to find an upper-bound, a worst case scenario if you will, for the size of $\lVert E_\text{final} \rVert_{\infty}$, then keep that well below the tolerable limit. Let’s break down some terms and concepts which we will be using first: </p>
<ul>
<li><p><strong>Decomposition Bound</strong>($B_\text{decomp}$): the coefficients of our plaintext parts $\Phi_i$ are small, bounded by $\lVert \Phi_i \rVert_{\infty} &lt; \frac{beta}{2}$, this bound is refered as $B_\text{decomp}$.</p>
</li>
<li><p><strong>Initial Noise Bound</strong>($B_\text{noise}$): noise polynomials $E_i$ are sampled from a tight distribution, so their coefficients are bounded by some value $B_\text{noise}$.</p>
</li>
<li><p><strong>Polynomial Multiplication Bound</strong>: when we multiply two polynomials $P$ and $Q$, the resulting coefficients are bounded: $\lVert P \cdot Q \rVert_{\infty} \leq n \cdot \lVert P \rVert_{\infty}\cdot \lVert Q \rVert_{\infty}$.</p>
</li>
</ul>
<p>Now, let’s build our worst-case noise estimate step-by-step:</p>
<ol>
<li><p><strong>Start with the final noise term:</strong><br>$$\lVert E_{final}\rVert_\infty &#x3D; \left\lVert \sum_{i&#x3D;1}^{l} \Phi_i \cdot E_i \right\rVert_\infty$$</p>
</li>
<li><p><strong>Apply the triangle inequality</strong> (the norm of a sum is at most the sum of the norms):<br>$$\le \sum_{i&#x3D;1}^{l} \lVert\Phi_i \cdot E_i\rVert_\infty$$</p>
</li>
<li><p><strong>Use the polynomial multiplication bound on each term:</strong><br>$$\le \sum_{i&#x3D;1}^{l} n \cdot \lVert\Phi_i\rVert_\infty \cdot \lVert E_i\rVert_\infty$$</p>
</li>
<li><p><strong>Finally, substitute our bounds</strong> for the decomposed parts ($B_{decomp}$) and the initial noise ($B_{noise}$):<br>$$\le \sum_{i&#x3D;1}^{l} n \cdot B_{\text{decomp}} \cdot B_{\text{noise}} &#x3D; l \cdot n \cdot B_{\text{decomp}} \cdot B_{\text{noise}}$$</p>
</li>
</ol>
<p>This gives us our upper bound on the final noise. Now, we just force this bound to be small enough for decryption to work:<br>$$l \cdot n \cdot B_{\text{decomp}} \cdot B_{\text{noise}} &lt; \frac{\Delta}{2}$$</p>
<p>This is the punchline. By substituting $B_{\text{decomp}} &#x3D; \beta&#x2F;2$ and our usual scaling factor $\Delta &#x3D; \lfloor q&#x2F;t \rfloor$, we get the master inequality that governs our choice of $\beta$:</p>
<p>$$\boxed{l \cdot n \cdot \frac{\beta}{2} \cdot B_{\text{noise}} &lt; \frac{\lfloor q&#x2F;t \rfloor}{2}}$$</p>
<p>Or, simplifying it for clarity:</p>
<p>$$\Large l \cdot n \cdot \beta \cdot B_{\text{noise}} &lt; \lfloor q&#x2F;t \rfloor$$</p>
<p>This final inequality is the key to selecting sound parameters. Think of it like this:</p>
<ul>
<li><strong>Right side ($\lfloor q&#x2F;t \rfloor$)</strong>: This is our total <strong>noise budget</strong>. It’s the maximum amount of noise the system can tolerate. To get a bigger budget, we need to increase the ratio of $q$ to $t$.</li>
<li><strong>Left side ($l \cdot n \cdot \beta \cdot B_{noise}$)</strong>: This is the <strong>total noise growth</strong> from our homomorphic multiplication.</li>
</ul>
<p>To ensure our scheme works, the <strong>total noise growth must be less than the noise budget</strong>. This formula perfectly captures the trade-offs we have to make. For instance, if we increase our decomposition base $\beta$, the noise growth per level increases, but the number of levels $l$ decreases. Finding the right balance is what FHE parameter selection is all about.</p>
<h3><span id="quick-implementation">Quick Implementation</span></h3><p>Ok, now let’s see a quick implementation of this concept. I have presented only the relevant C++ code snippets, the full code can be found at this <a target="_blank" rel="noopener" href="https://github.com/DA1729/gadget_decomp_blog.git">repo</a>.</p>
<p>Our basic data structures: </p>
<ul>
<li><code>poly</code>: a <code>vec&lt;int64_t&gt;</code> representing a polynomial.</li>
<li><code>GLWE_ciphertext</code>: a struct containing a vector of polynomials <code>D</code> and a single polynomial <code>B</code>.</li>
<li><code>GLev_ciphertext</code>: a vector of <code>GLWE_ciphertext</code>.</li>
</ul>
<h4><span id="gadget-decomposition-function">Gadget Decomposition Function</span></h4><p>This function, as the name suggests, would perform the gadget decomposition of the referenced polynomial <code>p</code> and return us a vector (length <code>l</code>) of decomposed polynomials. The implementation is using the standard rounding method to find the closest coefficients for each component. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;poly&gt; <span class="title">gadget_decompose</span><span class="params">(<span class="type">const</span> poly &amp;p, <span class="type">int64_t</span> q, <span class="type">int64_t</span> beta, <span class="type">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;poly&gt; <span class="title">decomp</span><span class="params">(l, poly(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">    poly current_rem = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; ++i) &#123;</span><br><span class="line">        <span class="type">int64_t</span> g = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i + <span class="number">1</span>; ++j) g *= beta;</span><br><span class="line">        g = q / g;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="type">int64_t</span> centered_rem = <span class="built_in">center_rep</span>(current_rem[j], q);</span><br><span class="line">            </span><br><span class="line">            <span class="type">int64_t</span> coeff = <span class="built_in">round</span>((<span class="type">double</span>)centered_rem / g);</span><br><span class="line"></span><br><span class="line">            decomp[i][j] = coeff;</span><br><span class="line">            </span><br><span class="line">            __int128 rem_update = (__int128)coeff * g;</span><br><span class="line">            current_rem[j] = <span class="built_in">modq</span>(current_rem[j] - (<span class="type">int64_t</span>)rem_update, q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> decomp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="external-product">External Product</span></h4><p>The core of the homomorphic operation (<code>ct-pt multiplication</code>). Function takes the decomposed plaintext <code>decomp_phi</code> and the <code>GLev Ciphertext</code>, then computes the sum of the component-wise products. The result is a single, final <code>GLWE_ciphertext</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GLWE_ciphertext <span class="title">external_product</span><span class="params">(<span class="type">const</span> vector&lt;poly&gt; &amp;decomp_phi, <span class="type">const</span> GLev_ciphertext &amp;c_glev, <span class="type">int64_t</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> n = c_glev[<span class="number">0</span>].B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> k = c_glev[<span class="number">0</span>].D.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> l = c_glev.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    GLWE_ciphertext result;</span><br><span class="line">    result.B = <span class="built_in">poly</span>(n, <span class="number">0</span>);</span><br><span class="line">    result.D.<span class="built_in">assign</span>(k, <span class="built_in">poly</span>(n, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; ++i) &#123;</span><br><span class="line">        <span class="comment">// C_i_scaled = decomp_phi[i] * c_glev[i]</span></span><br><span class="line">        poly b_scaled = <span class="built_in">poly_scalar_mul</span>(c_glev[i].B, decomp_phi[i][<span class="number">0</span>], q);</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;poly&gt; <span class="title">d_scaled</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;k; ++j) &#123;</span><br><span class="line">            d_scaled[j] = <span class="built_in">poly_scalar_mul</span>(c_glev[i].D[j], decomp_phi[i][<span class="number">0</span>], q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result.B = <span class="built_in">poly_add</span>(result.B, b_scaled, q);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">            result.D[j] = <span class="built_in">poly_add</span>(result.D[j], d_scaled[j], q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4><span id="result">Result</span></h4><p>Running the full code (available on my GitHub), we get: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">------ Parameters ------</span><br><span class="line">n: 1024, q: 2^32, t: 256, k: 2</span><br><span class="line">beta: 1024, l: 3</span><br><span class="line">Original Message M(x) = 5</span><br><span class="line">Plaintext Multiplier Φ(x) = 12</span><br><span class="line">Expected Result (M * Φ) = 60</span><br><span class="line"></span><br><span class="line">------ Operations ------</span><br><span class="line">Encrypting M=5 into a GLev ciphertext...</span><br><span class="line">Decomposing Φ=12 into (Φ_1, Φ_2, ...)...</span><br><span class="line">Performing homomorphic external product...</span><br><span class="line">Decryption of the final ciphertext...</span><br><span class="line">------ Noise Analysis ------</span><br><span class="line">Correctness requires noise &lt; q/(2t) = 8388608</span><br><span class="line"></span><br><span class="line">Noise from Gadget Method: 1668</span><br><span class="line">Noise from Naive Method: 8232</span><br><span class="line"></span><br><span class="line">The gadget-based multiplication resulted in noise ~4x smaller than the naive approach!</span><br></pre></td></tr></table></figure>

<p>The results are obviously matching the expectations. </p>
<h2><span id="conclusion">Conclusion</span></h2><p>This brings us to the end. In this blog, we first quickly revisited LWE, RLWE, then we designed two generalized systems, GLWE and GLev. Then, studying a very specific homomorphic operation(<code>ct-pt multiplication</code>), we made us realize the need for the gadget decomposition. One can already appereciate the benefits (obv we have the tradeoffs, but it’s alright) we get using this technique. This concept is very very crucial when we build more <strong>complex evaluation systems</strong> and this appears a lot when we deal with even more complex and crucial operations like <strong>bootstrapping</strong>, <strong>key-switch</strong>, <strong>modulus switching</strong>, etc.</p>

    </div>
  </div>
</article>
        </main>
        
        <!-- Sidebar -->
        <aside class="sidebar">
          <!-- Sidebar Widgets -->

<!-- Recent Posts Widget -->

  <div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <ul>
      
        <li>
          <a href="/2025/12/03/Mult-Party-Computation-part-2/">Multi-Party Computation part 2</a>
          <div style="font-size: 0.8em; color: var(--text-secondary); margin-top: 4px;">
            Dec 3, 2025
          </div>
        </li>
      
        <li>
          <a href="/2025/12/01/Multi-Party-Computation/">Multi-Party Computation part 1</a>
          <div style="font-size: 0.8em; color: var(--text-secondary); margin-top: 4px;">
            Dec 1, 2025
          </div>
        </li>
      
        <li>
          <a href="/2025/09/27/Need-for-Gadget-Decomposition-in-LWE-Based-Cryptosystems/">Need for Gadget Decomposition in LWE Based Cryptosystems</a>
          <div style="font-size: 0.8em; color: var(--text-secondary); margin-top: 4px;">
            Sep 27, 2025
          </div>
        </li>
      
        <li>
          <a href="/2025/09/14/AGI-running-on-Quantum-Chip/">AGI running on Quantum Chip?</a>
          <div style="font-size: 0.8em; color: var(--text-secondary); margin-top: 4px;">
            Sep 14, 2025
          </div>
        </li>
      
        <li>
          <a href="/2025/08/15/Ring-LWE-and-CKKS-Mathematical-Foundations/">Ring-LWE and CKKS: Mathematical Foundations for Homomorphic Encryption</a>
          <div style="font-size: 0.8em; color: var(--text-secondary); margin-top: 4px;">
            Aug 15, 2025
          </div>
        </li>
      
    </ul>
  </div>


<!-- Categories Widget -->


<!-- Tags Widget -->

  <div class="widget">
    <h3 class="widget-title">Tags</h3>
    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
      
        <a href="/tags/AI-Acceleration/" class="tag">
          #AI - Acceleration
        </a>
      
        <a href="/tags/AI-Acceleration/" class="tag">
          #AI Acceleration
        </a>
      
        <a href="/tags/Abstract-Algebra/" class="tag">
          #Abstract Algebra
        </a>
      
        <a href="/tags/Analog/" class="tag">
          #Analog
        </a>
      
        <a href="/tags/Cryptanalysis/" class="tag">
          #Cryptanalysis
        </a>
      
        <a href="/tags/Cryptography/" class="tag">
          #Cryptography
        </a>
      
        <a href="/tags/Fully-Homomorphic-Encryption/" class="tag">
          #Fully Homomorphic Encryption
        </a>
      
        <a href="/tags/Hardware-Acceleration/" class="tag">
          #Hardware Acceleration
        </a>
      
        <a href="/tags/Philosphy/" class="tag">
          #Philosphy
        </a>
      
        <a href="/tags/Post-Quantum-Cryptography/" class="tag">
          #Post Quantum Cryptography
        </a>
      
        <a href="/tags/Post-Quantum-Cryptography/" class="tag">
          #Post-Quantum Cryptography
        </a>
      
        <a href="/tags/Ring-Theory/" class="tag">
          #Ring Theory
        </a>
      
        <a href="/tags/Secure-Computing/" class="tag">
          #Secure Computing
        </a>
      
        <a href="/tags/VLSI/" class="tag">
          #VLSI
        </a>
      
    </div>
  </div>


<!-- Archive Widget -->

  <div class="widget">
    <h3 class="widget-title">Archive</h3>
    <ul>
      
      
        
          <li>
            <a href="/archives/2025/">
              December 2025 (2)
            </a>
          </li>
        
          <li>
            <a href="/archives/2025/">
              September 2025 (2)
            </a>
          </li>
        
          <li>
            <a href="/archives/2025/">
              August 2025 (1)
            </a>
          </li>
        
          <li>
            <a href="/archives/2025/">
              July 2025 (1)
            </a>
          </li>
        
          <li>
            <a href="/archives/2025/">
              April 2025 (2)
            </a>
          </li>
        
          <li>
            <a href="/archives/2025/">
              March 2025 (2)
            </a>
          </li>
        
      
    </ul>
  </div>


<!-- About Widget -->
<div class="widget">
  <h3 class="widget-title">About</h3>
  <p style="font-size: 0.9em; line-height: 1.6;">
    Welcome to my blog! Here I write about various topics including technology, programming, and more.
  </p>
  
  
    <div style="margin-top: 15px;">
      <strong style="font-size: 0.9em;">Find me on:</strong>
      <div style="margin-top: 8px; display: flex; flex-wrap: wrap; gap: 8px;">
        
          <a href="https://github.com/DA1729" class="tag" target="_blank" rel="noopener">
            github
          </a>
        
          <a href="https://x.com/sp0oky_daksh" class="tag" target="_blank" rel="noopener">
            twitter
          </a>
        
          <a href="mailto:dakshpandey177@gmail.com" class="tag" target="_blank" rel="noopener">
            email
          </a>
        
          <a href="https://sp0oky-portfolio.vercel.app/" class="tag" target="_blank" rel="noopener">
            portfolio
          </a>
        
      </div>
    </div>
  
  
  <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color);">
    <p style="font-size: 0.8em; color: var(--text-secondary); opacity: 0.8;">
      Theme designed with 
      <a href="https://claude.ai/code" target="_blank" rel="noopener" style="color: var(--link-color); text-decoration: none;">Claude Code</a>
    </p>
  </div>
</div>
        </aside>
      </div>
    </div>

    <!-- Footer -->
    <footer class="footer">
      <p>© 2025 Daksh Pandey. Portfolio-inspired theme crafted with Claude Code.</p>
    </footer>
  </div>

  <!-- JavaScript -->
  
<script src="/js/main.js"></script>

  
  <!-- Math Support -->
  
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          ignoreHtmlClass: 'tex2jax_ignore',
          processHtmlClass: 'tex2jax_process'
        }
      };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  
</body>
</html>