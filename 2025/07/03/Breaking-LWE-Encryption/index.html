<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Breaking LWE Encryption Part 1 | da1729&#39;s Blog</title>
  
  <!-- SEO Meta Tags -->
  <meta name="description" content="">
  <meta name="keywords" content="">
  <meta name="author" content="Daksh Pandey">
  
  <!-- Open Graph -->
  <meta property="og:title" content="Breaking LWE Encryption Part 1">
  <meta property="og:description" content="">
  <meta property="og:type" content="post">
  <meta property="og:url" content="/2025/07/03/Breaking-LWE-Encryption/">
  <meta property="og:site_name" content="da1729&#39;s Blog">
  
  <!-- CSS -->
  
<link rel="stylesheet" href="/css/style.css">

  
  <!-- RSS Feed -->
  
  
  <!-- Favicon -->
  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div class="page-wrapper">
    <!-- Header -->
    <header class="header">
      <h1>
        <a href="/" class="site-title">da1729&#39;s Blog</a>
      </h1>
      
        <p class="site-subtitle">cryptography, digital design, embedded, rf, ...</p>
      
      
      <!-- Navigation -->
      <nav class="nav">
        
          <a href="/" class="nav-link">Home</a>
        
          <a href="/archives" class="nav-link">Archives</a>
        
          <a href="/about" class="nav-link">About</a>
        
        
        <!-- Social Links -->
        
          
            <a href="https://github.com/DA1729" class="nav-link" target="_blank" rel="noopener">github</a>
          
            <a href="https://x.com/sp0oky_daksh" class="nav-link" target="_blank" rel="noopener">twitter</a>
          
            <a href="mailto:dakshpandey177@gmail.com" class="nav-link" target="_blank" rel="noopener">email</a>
          
            <a href="https://sp0oky-portfolio.vercel.app/" class="nav-link" target="_blank" rel="noopener">portfolio</a>
          
        
      </nav>
    </header>

    <!-- Main Content -->
    <div class="container">
      <div class="content">
        <main class="main-content">
          <!-- Individual Post Page -->
<article class="article-card">
  <header class="article-header">
    <div class="article-meta">
      <time datetime="2025-07-03T04:11:40.000Z">
        July 3, 2025
      </time>
      
      
        <span> • Updated: August 20, 2025</span>
      
    </div>
    
    <h1 class="article-title">Breaking LWE Encryption Part 1</h1>
    
    
      <div class="article-tags">
        
          <a href="/tags/Cryptography/" class="tag">#Cryptography</a>
        
          <a href="/tags/Cryptanalysis/" class="tag">#Cryptanalysis</a>
        
          <a href="/tags/Post-Quantum-Cryptography/" class="tag">#Post Quantum Cryptography</a>
        
          <a href="/tags/Fully-Homomorphic-Encryption/" class="tag">#Fully Homomorphic Encryption</a>
        
      </div>
    
  </header>
  
  <div class="article-content">
    <div class="post-content">
      <p>Ok, the title is an absolute clickbait. We are not “breaking” breaking the LWE Encryption, cuz it’s used a lot in <strong>Post-Quantum Cryptography</strong>, so it is supposed to remain intact even against a fully functioning Quantum Computer. In this blog, I am emphasizing the fact that whenever one has to encrypt something really important, or let’s say they own a startup and want to encrypt their company’s data, one must always use the standardized crypto libraries and tools like <strong>OpenSSL</strong>, <strong>RustCrypto</strong>, <strong>OQS</strong> (for post-quantum), etc. Cuz, by doing some clever thinking, your own code encoding an “Attack Proof” crypto scheme, can be broken. And, I’ll show that by breaking an LWE encryption which I coded in C++. Infact, I’ll break it in two different ways.</p>
<p>But before that, what is LWE?</p>
<span id="more"></span>

<h2><span id="table-of-contents">Table of Contents</span></h2><ul>
<li><a href="#lwe-learning-with-errors">LWE (Learning With Errors)</a></li>
<li><a href="#lwe-encryption">LWE Encryption</a></li>
<li><a href="#lwe-decryption">LWE Decryption</a></li>
<li><a href="#code-which-we-are-going-to-break">Code which we are going to BREAK</a></li>
<li><a href="#cryptanalysis-of-lazily-coded-lwe">Cryptanalysis of Lazily Coded LWE</a></li>
<li><a href="#machine-learning-attack">Machine Learning Attack</a><ul>
<li><a href="#data-generation">Data generation</a></li>
<li><a href="#model-for-single-bit-prediction">Model for Single Bit Prediction</a></li>
</ul>
</li>
<li><a href="#updates">Updates</a></li>
</ul>
<h2><span id="lwe-learning-with-errors">LWE (Learning With Errors)</span></h2><p>LWE or Learngin With Errors, is a <strong>hard</strong> mathematical problem. The mathematical definition from Wikipedia is as follows:</p>
<div style="border-left: 4px solid #007acc; padding: 10px; background-color: #f9f9f9; text-align: justify;">

<p>Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">Z</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">\mathbb{Z}_q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.975em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> denote the ring of integers modulo <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> and let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="double-struck">Z</mi><mi>q</mi><mi>n</mi></msubsup></mrow><annotation encoding="application/x-tex">\mathbb{Z}_q^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.072em;vertical-align:-0.3831em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em;"><span></span></span></span></span></span></span></span></span></span> denote the set of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-vectors over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">Z</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">\mathbb{Z}_q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.975em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>. There exists a certain unknown linear function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msubsup><mi mathvariant="double-struck">Z</mi><mi>q</mi><mi>n</mi></msubsup><mo>→</mo><msub><mi mathvariant="double-struck">Z</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">f : \mathbb{Z}_q^n \to \mathbb{Z}_q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.072em;vertical-align:-0.3831em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.975em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>, and the input to the LWE problem is a sample of pairs <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\mathbf{x}, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi><mo>∈</mo><msubsup><mi mathvariant="double-struck">Z</mi><mi>q</mi><mi>n</mi></msubsup></mrow><annotation encoding="application/x-tex">\mathbf{x} \in \mathbb{Z}_q^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathbf">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.072em;vertical-align:-0.3831em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>∈</mo><msub><mi mathvariant="double-struck">Z</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">y \in \mathbb{Z}_q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.975em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>, so that with high probability <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y = f(\mathbf{x})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mclose">)</span></span></span></span>. Furthermore, the deviation from the equality is according to some known noise model. The problem calls for finding the function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>, or some close approximation thereof, with high probability.</p>
</div>

<p>This seems complex, but tbh, still better than other mathematical definitions for other stuff. One can get the idea from the above definition, that LWE problem is to find a solution to a set of linear equations with noise added to the system. Now, one might ask why this is hard to solve, proving that is out of scope for this blog, but for the curious who don’t fear a long mathematical detour, here you go: <a target="_blank" rel="noopener" href="https://arxiv.org/abs/1306.0281">Classical Hardness of LWE</a>.</p>
<h2><span id="lwe-encryption">LWE Encryption</span></h2><p>Now, that we know the crux of the problem, let’s jump straight into encryption using this problem.</p>
<p>So, an LWE ciphertext consists of a random public vector <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><msubsup><mi mathvariant="double-struck">Z</mi><mi>q</mi><mi>n</mi></msubsup></mrow><annotation encoding="application/x-tex">a \in \mathbb{Z}_q^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.072em;vertical-align:-0.3831em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em;"><span></span></span></span></span></span></span></span></span></span> and an additional element <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mi>a</mi><mo>⋅</mo><mi>s</mi><mo>+</mo><mi mathvariant="normal">Δ</mi><mo>⋅</mo><mi>m</mi><mo>+</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">b = a \cdot s + \Delta \cdot m + e </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> mod <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>. Let’s break this down further:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> is the **secret key**. Here, it is being randomly sampled from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mo stretchy="false">}</mo><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\{0, 1\}^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>.
</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> is the message. It is important to note that the message space has to be considerably small as compared to the integer ring <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">Z</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">\mathbb{Z}_q </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.975em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> in order to stop the ciphertext becoming random noise instead of encrypted data. In fact, we define another number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>, which is in general a power of 2. The power represents the number of bits required to represent any element from the message space.
</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span></span></span></span> is the scaling factor, which equals <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>q</mi><mi>p</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{q}{p} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2286em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>. So, by multiplying this scaling factor to our message, what is happening is, we are shifting the message bits to the most significant portions of an n bit structure.
</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> is the noise term and it is sampeled from a discrete Gaussian distribution with small standard distribution. Now, noise should not be too large that it affects the Most Significant Bits of the encoded message during the addition.</li>
</ul>
<h2><span id="lwe-decryption">LWE Decryption</span></h2><p>Decryption process is fairly simple. First, assuming that the receiver obviously has the secret key (NOTE: We have discussed the symmetric scheme here, it is also possible to devise an assymetric scheme usng LWE). The receiver will re-compute the dot product of the secret key and the public vector. Then, subtract the result from b. After that, perform an operation known as ROUND, which removes the error. Then we can just rescale the end result to get our decrypted plain-text.</p>
<p>Now that we are done with encryption and decryption using LWE, we can move forward having a look at the code and attacking strategies. I know that I have not explained the above concepts in a hurry cuz there are way better resources for studying about LWE, than here. So I would highly recommend checking out some blogs and papers online on LWE for a better understanding. I’ll also link some here:</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://www.jeremykun.com/2024/05/04/fhe-overview/#lwe-and-rlwe">Jeremy Kun’s Blog on FHE Overview</a>: He does a great job in explaining LWE and it’s sibling RLWE through words. Really good for an intuitive understanding. His other blogs are also very good and interesting. They cover crypto, signal processing. ML, Category Theory, and many more very interesting topics.</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=npoHSR6-oRw&t=5958s">TFHE Deep Dive talk by Ilaria chillotti</a>: It’s a really great talk for someone interested in getting into Homomorphic Encryption from mathematical perspective. Ilaria is one of the co-authors of the original TFHE (an FHE scheme) paper, and she does a great job explaining LWE, RLWE and RGSW.</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://web.stanford.edu/class/cs354/scribe/lecture14.pdf">Stanford Lecture on LWE</a>: For those serious about crypto. More math intensive, but more serious you are about crypto more you have to start dealing with rigrous abstract math.</p>
</li>
<li><p>Google, ChatGPT, Claude, what else do you want.</p>
</li>
</ul>
<h2><span id="code-which-we-are-going-to-break">Code which we are going to BREAK</span></h2><p>Now, let’s see the code which I will attempt to break. It encodes LWE encryption and decryption in a very naive manner or how I would imagine a person without a serious security team to code an LWE scheme. We’ll go block by block and you can find all the codes related to the blog in this <a target="_blank" rel="noopener" href="https://github.com/DA1729/breaking-lwe">repo</a>.</p>
<h3><span id="defining-the-parameters">Defining the parameters</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> n = <span class="number">512</span>;           <span class="comment">// security parameter</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> q = <span class="number">12289</span>;         <span class="comment">// large prime modulus</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> p = <span class="number">4</span>;             <span class="comment">// message space &#123;0,1,2,3&#125;</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> delta = q / p;     <span class="comment">// scaling factor for encoding</span></span><br></pre></td></tr></table></figure>

<p>This is pretty self explanatory, just refer to the above definitions of the labeled terms, things will make sense. One thing to note, is that our message space is only <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{0, 1, 2, 3\} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mclose">}</span></span></span></span>, which might seem very impractical and something worth not break into. Give me a larger message space? Cool, I’ll just scale the attack — or ignore it if the noise already eats the message anyway. In other words, encryption is practically pure noise.</p>
<h3><span id="noise-sampling">Noise sampling</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// noise sampling</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sample_discrete_gaussian</span><span class="params">(std::mt19937&amp; gen, <span class="type">double</span> sigma = <span class="number">3.2</span>)</span> </span>&#123;</span><br><span class="line">    std::normal_distribution&lt;&gt; <span class="built_in">dist</span>(<span class="number">0.0</span>, sigma);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(std::<span class="built_in">round</span>(<span class="built_in">dist</span>(gen))) % q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here, a confusion might arise at the return statement. So the sample from a Gaussian distribution comes out as a double value in C++, but I want it to be an integer instead, NOO floating point headache. And, we really do want an “integer” sample from the distribution, and aditionally, it has to be in the ring <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">Z</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">\mathbb{Z}_q </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.975em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>, so I casted the double as an integer by first rounding it of course. Then I reduced it modulo <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>.</p>
<h3><span id="secret-key-generation">Secret key generation</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// secret key</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">key_gen</span><span class="params">(std::mt19937&amp; gen)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">std::bernoulli_distribution <span class="title">bern</span><span class="params">(<span class="number">0.5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; si : s) si = <span class="built_in">bern</span>(gen);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Secret key, here, is just a vector of binary digits of length <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>. So, I just sampeled from a Bernoulli Distribution (with success probability equal to half), <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> times.</p>
<h3><span id="encryption">Encryption</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// encryption</span></span><br><span class="line">std::pair&lt;std::vector&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt; <span class="built_in">encrypt</span>(<span class="type">int</span> m, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; s, std::mt19937&amp; gen) &#123;</span><br><span class="line">    std::uniform_int_distribution&lt;&gt; <span class="built_in">uniform_q</span>(<span class="number">0</span>, q - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; ai : a) ai = <span class="built_in">uniform_q</span>(gen);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> e = <span class="built_in">sample_discrete_gaussian</span>(gen);</span><br><span class="line">    <span class="type">int</span> b = (<span class="built_in">dot_mod_q</span>(a, s) + delta * m + e) % q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;a, b&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this function, we first sample the public vector of length <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>. Then things are pretty straight forward and matches one-on-one with the definitions above. Also, <code>dot_mod_q</code> ain’t a standard C++ function. It’s a function I wrote and did not explain in detail cuz it’s very simple to understand.</p>
<h3><span id="decryption">Decryption</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decryption</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">decrypt</span><span class="params">(<span class="type">const</span> std::pair&lt;std::vector&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt;&amp; ct, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; a = ct.first;</span><br><span class="line">    <span class="type">int</span> b = ct.second;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> phase = (b - <span class="built_in">dot_mod_q</span>(a, s) + q) % q;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(std::<span class="built_in">round</span>((<span class="type">double</span>)phase / delta)) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this function, one can see the rounding step in the return statement. Rest, everything here too matches the one-on-one with the definitions above.</p>
<p>Now putting it all together, we have the following:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> n = <span class="number">512</span>;           <span class="comment">// security parameter</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> q = <span class="number">12289</span>;         <span class="comment">// large prime modulus</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> p = <span class="number">4</span>;             <span class="comment">// message space &#123;0,1,2,3&#125;</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> delta = q / p;     <span class="comment">// scaling factor for encoding</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// noise sampling</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sample_discrete_gaussian</span><span class="params">(std::mt19937&amp; gen, <span class="type">double</span> sigma = <span class="number">3.2</span>)</span> </span>&#123;</span><br><span class="line">    std::normal_distribution&lt;&gt; <span class="built_in">dist</span>(<span class="number">0.0</span>, sigma);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(std::<span class="built_in">round</span>(<span class="built_in">dist</span>(gen))) % q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// secret key</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">key_gen</span><span class="params">(std::mt19937&amp; gen)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">std::bernoulli_distribution <span class="title">bern</span><span class="params">(<span class="number">0.5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; si : s) si = <span class="built_in">bern</span>(gen);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dot_mod_q</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(a.<span class="built_in">size</span>() == b.<span class="built_in">size</span>());</span><br><span class="line">    <span class="type">int64_t</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        sum += <span class="built_in">static_cast</span>&lt;<span class="type">int64_t</span>&gt;(a[i]) * b[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(sum % q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// encryption</span></span><br><span class="line">std::pair&lt;std::vector&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt; <span class="built_in">encrypt</span>(<span class="type">int</span> m, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; s, std::mt19937&amp; gen) &#123;</span><br><span class="line">    std::uniform_int_distribution&lt;&gt; <span class="built_in">uniform_q</span>(<span class="number">0</span>, q - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; ai : a) ai = <span class="built_in">uniform_q</span>(gen);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> e = <span class="built_in">sample_discrete_gaussian</span>(gen);</span><br><span class="line">    <span class="type">int</span> b = (<span class="built_in">dot_mod_q</span>(a, s) + delta * m + e) % q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;a, b&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// decryption</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">decrypt</span><span class="params">(<span class="type">const</span> std::pair&lt;std::vector&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt;&amp; ct, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; a = ct.first;</span><br><span class="line">    <span class="type">int</span> b = ct.second;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> phase = (b - <span class="built_in">dot_mod_q</span>(a, s) + q) % q;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(std::<span class="built_in">round</span>((<span class="type">double</span>)phase / delta)) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::random_device rd;</span><br><span class="line">    <span class="function">std::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; s = <span class="built_in">key_gen</span>(gen);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Testing encryption over message space &#123;0,1,2,3&#125;:\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; p; ++m) &#123;</span><br><span class="line">        <span class="keyword">auto</span> ct = <span class="built_in">encrypt</span>(m, s, gen);</span><br><span class="line">        <span class="type">int</span> recovered = <span class="built_in">decrypt</span>(ct, s);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Original: &quot;</span> &lt;&lt; m</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; | Decrypted: &quot;</span> &lt;&lt; recovered</span><br><span class="line">                  &lt;&lt; ((m != recovered) ? <span class="string">&quot; ❌&quot;</span> : <span class="string">&quot; ✅&quot;</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And here is the output of the code:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Testing encryption over message space &#123;0,1,2,3&#125;:</span><br><span class="line">Original: 0 | Decrypted: 0 ✅</span><br><span class="line">Original: 1 | Decrypted: 1 ✅</span><br><span class="line">Original: 2 | Decrypted: 2 ✅</span><br><span class="line">Original: 3 | Decrypted: 3 ✅</span><br></pre></td></tr></table></figure>

<p>Ok, so now that we are done with the basics, now actually get into the main stuff. Breaking it.</p>
<h2><span id="cryptanalysis-of-lazily-coded-lwe">Cryptanalysis of Lazily Coded LWE</span></h2><p>So before we dive into this interesting topic. Let’s make a few things clear.</p>
<ul>
<li><p>It is obvious that the code presented above is publicly available, owing to the <strong>Kerckhoff’s Principle</strong> which states that <strong>cryptosystem should be secure even if everything about the system, except the key, is public knowledge.</strong></p>
</li>
<li><p><strong>Access to ciphertexts</strong>: We assume a chosen-plaintext or known-plaintext scenario, meaning we either know the original message or can encrypt arbitrary messages and collect ciphertexts.</p>
</li>
<li><p><strong>Implementation-level behavior</strong>: We consider not just the mathematics, but also how the algorithm is implemented — which opens up potential side channels like timing variations or key reuse.</p>
</li>
<li><p><strong>Goal of cryptanalysis</strong>: We aim to recover the secret key <code>s</code>, distinguish ciphertexts from random noise, or infer plaintexts under various attack models, using practical and scalable methods — including statistical, lattice-based, and implementation-aware attacks.</p>
</li>
<li><p><strong>Math alert</strong>: I will go heavy on math at some places, cuz it would be necessary in the parts where we exploit the parameters selection for the system.</p>
</li>
</ul>
<p>Now let’s start with the method which includes less abstract maths.</p>
<h2><span id="machine-learning-attack">Machine Learning Attack</span></h2><p>Now let’s start diving easy. I don’t wanna overwhelm anyone with loads of complex info. Let’s go easy and step by step. First, ML means training, which needs data. What will be the data?</p>
<h3><span id="data-generation">Data generation</span></h3><p>We, are collecting LWE samples which are tuples of the form: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="bold">a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>∈</mo><msubsup><mi mathvariant="double-struck">Z</mi><mi>q</mi><mi>n</mi></msubsup><mo>×</mo><msub><mi mathvariant="double-struck">Z</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">(\mathbf{a}, b) \in \mathbb{Z}_q^n \times \mathbb{Z}_q </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathbf">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.072em;vertical-align:-0.3831em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.975em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>, where each sample obviously follows:</p>
<p style="text-align:center;">
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mo stretchy="false">⟨</mo><mi mathvariant="bold">a</mi><mo separator="true">,</mo><mi mathvariant="bold">s</mi><mo stretchy="false">⟩</mo><mo>+</mo><mi>e</mi><mo>+</mo><mi mathvariant="normal">Δ</mi><mi>m</mi><mspace></mspace><mspace width="0.6667em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>q</mi></mspace></mrow><annotation encoding="application/x-tex">b = \langle \mathbf{a}, \mathbf{s} \rangle + e + \Delta m \mod q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathbf">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathbf">s</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span><span class="mord mathnormal">m</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>.
</p>

<p>Along with these tuples, we are also collecting the corresponding secret keys.</p>
<p>Now, for training purposes, we will only use the public vectors <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">a</mi></mrow><annotation encoding="application/x-tex">\mathbf{a} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"></span><span class="mord mathbf">a</span></span></span></span>s as the <strong>input vectors</strong> and the corresponding secret key bits as <strong>target-labels</strong>.</p>
<p>Analyzing the data we collected and the data we’ll use for the training, we can infer that we are casting this <strong>LWE secret key</strong> problem as a <strong>supervised classification task</strong>. Where, each bit position of the secret key is treated as a separate <strong>binary classification problem</strong>.</p>
<p>For those not so familiar with ML concepts (like me lol), <strong>supervised classification task</strong> is a task, where we have a <strong>labeled dataset</strong>: each input (feature vector) is mapped with the correct output <strong>label</strong>. And the goal is to <strong>train</strong> the model to learn mapping from input to labels, so it can classify <strong>new, unseen inputs</strong>. And <strong>binary classification</strong> means that output (lables) are from a finite set of two elements, 0 and 1 in our case.</p>
<p>Here, is the python code for data generation and preparation of the training data:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">n = <span class="number">512</span></span><br><span class="line">q = <span class="number">12289</span></span><br><span class="line">p = <span class="number">4</span></span><br><span class="line">delta = q // p</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lwe_data_generator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cpp_executable_path = <span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.cpp_code = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="string">#include &lt;vector&gt;</span></span><br><span class="line"><span class="string">#include &lt;random&gt;</span></span><br><span class="line"><span class="string">#include &lt;cmath&gt;</span></span><br><span class="line"><span class="string">#include &lt;cassert&gt;</span></span><br><span class="line"><span class="string">constexpr int n = 512;</span></span><br><span class="line"><span class="string">constexpr int q = 12289;</span></span><br><span class="line"><span class="string">constexpr int p = 4;</span></span><br><span class="line"><span class="string">constexpr int delta = q / p;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int sample_discrete_gaussian(std::mt19937&amp; gen, double sigma = 3.2) &#123;</span></span><br><span class="line"><span class="string">    std::normal_distribution&lt;&gt; dist(0.0, sigma);</span></span><br><span class="line"><span class="string">    return static_cast&lt;int&gt;(std::round(dist(gen))) % q;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">std::vector&lt;int&gt; key_gen(std::mt19937&amp; gen) &#123;</span></span><br><span class="line"><span class="string">    std::vector&lt;int&gt; s(n);</span></span><br><span class="line"><span class="string">    std::bernoulli_distribution bern(0.5);</span></span><br><span class="line"><span class="string">    for (int&amp; si : s) si = bern(gen);</span></span><br><span class="line"><span class="string">    return s;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int dot_mod_q(const std::vector&lt;int&gt;&amp; a, const std::vector&lt;int&gt;&amp; b) &#123;</span></span><br><span class="line"><span class="string">    assert(a.size() == b.size());</span></span><br><span class="line"><span class="string">    int64_t sum = 0;</span></span><br><span class="line"><span class="string">    for (size_t i = 0; i &lt; a.size(); ++i)</span></span><br><span class="line"><span class="string">        sum += static_cast&lt;int64_t&gt;(a[i]) * b[i];</span></span><br><span class="line"><span class="string">    return static_cast&lt;int&gt;(sum % q);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">std::pair&lt;std::vector&lt;int&gt;, int&gt; encrypt(int m, const std::vector&lt;int&gt;&amp; s, std::mt19937&amp; gen) &#123;</span></span><br><span class="line"><span class="string">    std::uniform_int_distribution&lt;&gt; uniform_q(0, q - 1);</span></span><br><span class="line"><span class="string">    std::vector&lt;int&gt; a(n);</span></span><br><span class="line"><span class="string">    for (int&amp; ai : a) ai = uniform_q(gen);</span></span><br><span class="line"><span class="string">    int e = sample_discrete_gaussian(gen);</span></span><br><span class="line"><span class="string">    int b = (dot_mod_q(a, s) + delta * m + e) % q;</span></span><br><span class="line"><span class="string">    return &#123;a, b&#125;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main() &#123;</span></span><br><span class="line"><span class="string">    std::random_device rd;</span></span><br><span class="line"><span class="string">    std::mt19937 gen(rd());</span></span><br><span class="line"><span class="string">    std::vector&lt;int&gt; s = key_gen(gen);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // Output secret key</span></span><br><span class="line"><span class="string">    std::cout &lt;&lt; &quot;SECRET:&quot;;</span></span><br><span class="line"><span class="string">    for (int si : s) std::cout &lt;&lt; &quot; &quot; &lt;&lt; si;</span></span><br><span class="line"><span class="string">    std::cout &lt;&lt; std::endl;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // Generate training samples</span></span><br><span class="line"><span class="string">    for (int i = 0; i &lt; 10000; ++i) &#123;</span></span><br><span class="line"><span class="string">        auto ct = encrypt(0, s, gen);  // Always encrypt 0 for key recovery</span></span><br><span class="line"><span class="string">        std::cout &lt;&lt; &quot;SAMPLE:&quot;;</span></span><br><span class="line"><span class="string">        for (int ai : ct.first) std::cout &lt;&lt; &quot; &quot; &lt;&lt; ai;</span></span><br><span class="line"><span class="string">        std::cout &lt;&lt; &quot; &quot; &lt;&lt; ct.second &lt;&lt; std::endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate_data</span>(<span class="params">self, num_samples = <span class="number">10000</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;generate lwe samples and secret key&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tempfile.NamedTemporaryFile(mode=<span class="string">&#x27;w&#x27;</span>, suffix=<span class="string">&#x27;.cpp&#x27;</span>, delete=<span class="literal">False</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(<span class="variable language_">self</span>.cpp_code)</span><br><span class="line">            cpp_file = f.name</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># compile</span></span><br><span class="line">            exe_file = cpp_file.replace(<span class="string">&#x27;.cpp&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            subprocess.run([<span class="string">&#x27;g++&#x27;</span>, <span class="string">&#x27;-o&#x27;</span>, exe_file, cpp_file], check=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># run and capture output</span></span><br><span class="line">            result = subprocess.run([exe_file], capture_output=<span class="literal">True</span>, text=<span class="literal">True</span>, check=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># parse output</span></span><br><span class="line">            lines = result.stdout.strip().split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># extract secret key</span></span><br><span class="line">            secret_line = [line <span class="keyword">for</span> line <span class="keyword">in</span> lines <span class="keyword">if</span> line.startswith(<span class="string">&#x27;SECRET:&#x27;</span>)][<span class="number">0</span>]</span><br><span class="line">            secret = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, secret_line.split()[<span class="number">1</span>:]))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># extract samples</span></span><br><span class="line">            sample_lines = [line <span class="keyword">for</span> line <span class="keyword">in</span> lines <span class="keyword">if</span> line.startswith(<span class="string">&#x27;SAMPLE:&#x27;</span>)]</span><br><span class="line">            samples = []</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> sample_lines:</span><br><span class="line">                parts = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, line.split()[<span class="number">1</span>:]))</span><br><span class="line">                a = parts[:-<span class="number">1</span>]  <span class="comment"># first n elements</span></span><br><span class="line">                b = parts[-<span class="number">1</span>]   <span class="comment"># last element</span></span><br><span class="line">                samples.append((a, b))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> np.array(secret), samples</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># cleanup</span></span><br><span class="line">            <span class="keyword">for</span> file <span class="keyword">in</span> [cpp_file, exe_file]:</span><br><span class="line">                <span class="keyword">if</span> os.path.exists(file):</span><br><span class="line">                    os.unlink(file)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_training_data</span>(<span class="params">secret, samples</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;convert LWE samples to ML training data&quot;&quot;&quot;</span></span><br><span class="line">    X = []  <span class="comment"># input vectors (a values)</span></span><br><span class="line">    y = []  <span class="comment"># target labels (secret bits)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> samples:</span><br><span class="line">        X.append(a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.array(X), np.array(secret)</span><br></pre></td></tr></table></figure>

<h3><span id="model-for-single-bit-prediction">Model for Single Bit Prediction</span></h3><p>Now, we construct a neural network for predicting a single bit of the secret key. First, let’s recall the fact that LWE encryption sample looks something like:</p>
<p style="text-align:center;">
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mo stretchy="false">⟨</mo><mi mathvariant="bold">a</mi><mo separator="true">,</mo><mi mathvariant="bold">s</mi><mo stretchy="false">⟩</mo><mo>+</mo><mi>e</mi><mo>+</mo><mi mathvariant="normal">Δ</mi><mi>m</mi><mspace></mspace><mspace width="0.6667em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>q</mi></mspace></mrow><annotation encoding="application/x-tex">b = \langle \mathbf{a}, \mathbf{s} \rangle + e + \Delta m \mod q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathbf">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathbf">s</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span><span class="mord mathnormal">m</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>.
</p>

<p>In out attack, the secret <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">s</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>s</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>s</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>s</mi><mn>511</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{s} = (s_0, s_1, \cdots, s_{511}) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"></span><span class="mord mathbf">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">511</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> is a 512-bit vector. The key idea is: <strong>can we learn the value of one secret bit <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> just from the vector <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">a</mi></mrow><annotation encoding="application/x-tex">\mathbf{a} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"></span><span class="mord mathbf">a</span></span></span></span></strong>. Another perspective, treat it like a classification problem-binary decision: is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn><mtext> or </mtext><mn>1</mn></mrow><annotation encoding="application/x-tex">s_i = 0 \text{ or } 1 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mord text"><span class="mord"> or </span></span><span class="mord">1</span></span></span></span>.</p>
<p>Now neural network (a fancy function approximator) takes in input values, and it learns to give the correct output through repeated training on examples.</p>
<p>In our case:</p>
<ul>
<li><strong>Input</strong>: the 512-dimension public vector from the LWE ciphertext.</li>
<li><strong>Output</strong>: prediction whether the secret bit is 0 or 1.</li>
</ul>
<p>To predict a single bit, we use a small feed-forward neural network. In other words, each layer passes its output to the next, in a simple pipelined manner.</p>
<p>Here’s how the network is structured:</p>
<table>
<thead>
<tr>
<th>Layer</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Input Layer</strong></td>
<td>Takes in the 512-length LWE vector <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">a</mi></mrow><annotation encoding="application/x-tex">\mathbf{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"></span><span class="mord mathbf">a</span></span></span></span></td>
</tr>
<tr>
<td><strong>Dense Layer (256 units)</strong></td>
<td>Fully connected to all input values, learns patterns</td>
</tr>
<tr>
<td><strong>Dropout (30%)</strong></td>
<td>Randomly disables some neurons during training to prevent overfitting</td>
</tr>
<tr>
<td><strong>Dense Layer (128 units)</strong></td>
<td>Learns more abstract features</td>
</tr>
<tr>
<td><strong>Dropout (30%)</strong></td>
<td>Again helps generalize</td>
</tr>
<tr>
<td><strong>Dense Layer (64 units)</strong></td>
<td>Further processing</td>
</tr>
<tr>
<td><strong>Output Layer (1 unit, sigmoid)</strong></td>
<td>Outputs a number between 0 and 1 representing probability that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">s_i = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td>
</tr>
</tbody></table>
<p>We train this model by feeding it:</p>
<ul>
<li>Thousands of LWE samples where the message is always 0.</li>
<li>The actual secret bit <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> corresponding to each sample.</li>
</ul>
<p>The model learns by adjusting internal weights to reduce the prediction errors. It utilizes:</p>
<ul>
<li><strong>Binary cross-entropy</strong>: a loss function for yes&#x2F;no predictions.</li>
<li><strong>Adam optimizer</strong>: a well-tuned optimizer that speeds up learning.</li>
<li><strong>Accuracy</strong>: to measure how often it correctly guesses the bit.</li>
</ul>
<p>Now don’t panic if you don’t understand much of these terms. I am also not an ML guy, and I had to do a lot of googling for getting these things down, I encourage you doing the same or just go with the flow with high level idea I presented for these things.</p>
<p>Anyways, the python code looks much shorter than the explanation :p</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_bit_model</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;neural network to predict one secret bit&quot;&quot;&quot;</span></span><br><span class="line">    model = keras.Sequential([</span><br><span class="line">        keras.layers.Dense(<span class="number">256</span>, activation = <span class="string">&#x27;relu&#x27;</span>, input_shape = (<span class="variable language_">self</span>.n)),</span><br><span class="line">        keras.layers.Dropout(<span class="number">0.3</span>),</span><br><span class="line">        keras.layers.Dense(<span class="number">128</span>, activation = <span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">        keras.layers.Dropout(<span class="number">0.3</span>),</span><br><span class="line">        keras.layers.Dense(<span class="number">64</span>, activation = <span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">        keras.layers.Dense(<span class="number">1</span>, activation = <span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    model.<span class="built_in">compile</span>(</span><br><span class="line">        optimizer = <span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">        loss = <span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">        metric = [<span class="string">&#x27;accuracy&#x27;</span>]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>

<p>The blog seems to be getting very big now. And I still have to train the model, which god knows if I’ll be able to do on my laptop or not. So let’s end this part here. See you very soon with part 2.</p>
<p>peace. da1729</p>
<h2><span id="updates">Updates</span></h2><p>I have trained the model and performed the attack. You can checkout this repo: <a target="_blank" rel="noopener" href="https://github.com/DA1729/lwe_ml_attack.git">LWE ML Cryptanalysis</a>. The full blog is coming out soon, I am a little busy with other stuff to write a big detailed blog for now, so I thought it’ll be good if I just made the repo public.</p>

    </div>
  </div>
</article>

<!-- Post Navigation -->

  <nav class="post-nav mt-2">
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
      
        <div class="widget">
          <div class="widget-title">Previous Post</div>
          <a href="/2025/08/15/Ring-LWE-and-CKKS-Mathematical-Foundations/">Ring-LWE and CKKS: Mathematical Foundations for Homomorphic Encryption</a>
        </div>
      
      
      
        <div class="widget">
          <div class="widget-title">Next Post</div>
          <a href="/2025/04/16/Lottery-Ticket-Hypothesis-for-Beginners-Part-2/">Lottery Ticket Hypothesis Part 2</a>
        </div>
      
    </div>
  </nav>


<!-- Related Posts -->

        </main>
        
        <!-- Sidebar -->
        <aside class="sidebar">
          <!-- Sidebar Widgets -->

<!-- Recent Posts Widget -->

  <div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <ul>
      
        <li>
          <a href="/2025/08/16/Implementing-Automorphisms-and-Key-Switching-for-CKKS-Based-Homomorphic-Encryption/">Automorphisms and Key Switching in LWE based Cryptosystems</a>
          <div style="font-size: 0.8em; color: var(--text-secondary); margin-top: 4px;">
            Aug 16, 2025
          </div>
        </li>
      
        <li>
          <a href="/2025/08/15/Ring-LWE-and-CKKS-Mathematical-Foundations/">Ring-LWE and CKKS: Mathematical Foundations for Homomorphic Encryption</a>
          <div style="font-size: 0.8em; color: var(--text-secondary); margin-top: 4px;">
            Aug 15, 2025
          </div>
        </li>
      
        <li>
          <a href="/2025/07/03/Breaking-LWE-Encryption/">Breaking LWE Encryption Part 1</a>
          <div style="font-size: 0.8em; color: var(--text-secondary); margin-top: 4px;">
            Jul 3, 2025
          </div>
        </li>
      
        <li>
          <a href="/2025/04/16/Lottery-Ticket-Hypothesis-for-Beginners-Part-2/">Lottery Ticket Hypothesis Part 2</a>
          <div style="font-size: 0.8em; color: var(--text-secondary); margin-top: 4px;">
            Apr 16, 2025
          </div>
        </li>
      
        <li>
          <a href="/2025/04/13/Lottery-Ticket-Hypothesis-for-Beginners/">Lottery Ticket Hypothesis Part-1</a>
          <div style="font-size: 0.8em; color: var(--text-secondary); margin-top: 4px;">
            Apr 13, 2025
          </div>
        </li>
      
    </ul>
  </div>


<!-- Categories Widget -->


<!-- Tags Widget -->

  <div class="widget">
    <h3 class="widget-title">Tags</h3>
    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
      
        <a href="/tags/AI-Acceleration/" class="tag">
          #AI - Acceleration
        </a>
      
        <a href="/tags/AI-Acceleration/" class="tag">
          #AI Acceleration
        </a>
      
        <a href="/tags/Abstract-Algebra/" class="tag">
          #Abstract Algebra
        </a>
      
        <a href="/tags/Analog/" class="tag">
          #Analog
        </a>
      
        <a href="/tags/Cryptanalysis/" class="tag">
          #Cryptanalysis
        </a>
      
        <a href="/tags/Cryptography/" class="tag">
          #Cryptography
        </a>
      
        <a href="/tags/Fully-Homomorphic-Encryption/" class="tag">
          #Fully Homomorphic Encryption
        </a>
      
        <a href="/tags/Hardware-Acceleration/" class="tag">
          #Hardware Acceleration
        </a>
      
        <a href="/tags/Post-Quantum-Cryptography/" class="tag">
          #Post Quantum Cryptography
        </a>
      
        <a href="/tags/Ring-Theory/" class="tag">
          #Ring Theory
        </a>
      
        <a href="/tags/VLSI/" class="tag">
          #VLSI
        </a>
      
    </div>
  </div>


<!-- Archive Widget -->

  <div class="widget">
    <h3 class="widget-title">Archive</h3>
    <ul>
      
      
        
          <li>
            <a href="/archives/2025/">
              August 2025 (2)
            </a>
          </li>
        
          <li>
            <a href="/archives/2025/">
              July 2025 (1)
            </a>
          </li>
        
          <li>
            <a href="/archives/2025/">
              April 2025 (2)
            </a>
          </li>
        
          <li>
            <a href="/archives/2025/">
              March 2025 (2)
            </a>
          </li>
        
      
    </ul>
  </div>


<!-- About Widget -->
<div class="widget">
  <h3 class="widget-title">About</h3>
  <p style="font-size: 0.9em; line-height: 1.6;">
    Welcome to my blog! Here I write about various topics including technology, programming, and more.
  </p>
  
  
    <div style="margin-top: 15px;">
      <strong style="font-size: 0.9em;">Find me on:</strong>
      <div style="margin-top: 8px; display: flex; flex-wrap: wrap; gap: 8px;">
        
          <a href="https://github.com/DA1729" class="tag" target="_blank" rel="noopener">
            github
          </a>
        
          <a href="https://x.com/sp0oky_daksh" class="tag" target="_blank" rel="noopener">
            twitter
          </a>
        
          <a href="mailto:dakshpandey177@gmail.com" class="tag" target="_blank" rel="noopener">
            email
          </a>
        
          <a href="https://sp0oky-portfolio.vercel.app/" class="tag" target="_blank" rel="noopener">
            portfolio
          </a>
        
      </div>
    </div>
  
  
  <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color);">
    <p style="font-size: 0.8em; color: var(--text-secondary); opacity: 0.8;">
      Theme designed with 
      <a href="https://claude.ai/code" target="_blank" rel="noopener" style="color: var(--link-color); text-decoration: none;">Claude Code</a>
    </p>
  </div>
</div>
        </aside>
      </div>
    </div>

    <!-- Footer -->
    <footer class="footer">
      <p>© 2025 Daksh Pandey. Portfolio-inspired theme crafted with Claude Code.</p>
    </footer>
  </div>

  <!-- JavaScript -->
  
<script src="/js/main.js"></script>

  
  <!-- Math Support -->
  
</body>
</html>