<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Breaking LWE Encryption Part 1 | da1729&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Ok, the title is an absolute clickbait. We are not “breaking” breaking the LWE Encryption, cuz it’s used a lot in Post-Quantum Cryptography, so it is supposed to remain intact even against a fully fun">
<meta property="og:type" content="article">
<meta property="og:title" content="Breaking LWE Encryption Part 1">
<meta property="og:url" content="https://da1729.github.io/2025/07/03/Breaking-LWE-Encryption/index.html">
<meta property="og:site_name" content="da1729&#39;s Blog">
<meta property="og:description" content="Ok, the title is an absolute clickbait. We are not “breaking” breaking the LWE Encryption, cuz it’s used a lot in Post-Quantum Cryptography, so it is supposed to remain intact even against a fully fun">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-07-03T04:11:40.000Z">
<meta property="article:modified_time" content="2025-07-03T21:38:10.234Z">
<meta property="article:author" content="Daksh Pandey">
<meta property="article:tag" content="Cryptography">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="da1729's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">da1729&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">cryptography, digital design, embedded, rf, ...</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://DA1729.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Breaking-LWE-Encryption" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/03/Breaking-LWE-Encryption/" class="article-date">
  <time class="dt-published" datetime="2025-07-03T04:11:40.000Z" itemprop="datePublished">2025-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Breaking LWE Encryption Part 1
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Ok, the title is an absolute clickbait. We are not “breaking” breaking the LWE Encryption, cuz it’s used a lot in <strong>Post-Quantum Cryptography</strong>, so it is supposed to remain intact even against a fully functioning Quantum Computer. In this blog, I am emphasizing the fact that whenever one has to encrypt something really important, or let’s say they own a startup and want to encrypt their company’s data, one must always use the standardized crypto libraries and tools like <strong>OpenSSL</strong>, <strong>RustCrypto</strong>, <strong>OQS</strong> (for post-quantum), etc. Cuz, by doing some clever thinking, your own code encoding an “Attack Proof” crypto scheme, can be broken. And, I’ll show that by breaking an LWE encryption which I coded in C++. Infact, I’ll break it in two different ways.</p>
<p>But before that, what is LWE?</p>
<span id="more"></span>

<h2 id="LWE-Learning-With-Errors"><a href="#LWE-Learning-With-Errors" class="headerlink" title="LWE (Learning With Errors)"></a>LWE (Learning With Errors)</h2><p>LWE or Learngin With Errors, is a <strong>hard</strong> mathematical problem. The mathematical definition from Wikipedia is as follows:</p>
<div style="border-left: 4px solid #007acc; padding: 10px; background-color: #f9f9f9; text-align: justify;">

<p>Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">Z</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">\mathbb{Z}_q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.975em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> denote the ring of integers modulo <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> and let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="double-struck">Z</mi><mi>q</mi><mi>n</mi></msubsup></mrow><annotation encoding="application/x-tex">\mathbb{Z}_q^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.072em;vertical-align:-0.3831em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em;"><span></span></span></span></span></span></span></span></span></span> denote the set of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-vectors over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">Z</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">\mathbb{Z}_q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.975em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>. There exists a certain unknown linear function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msubsup><mi mathvariant="double-struck">Z</mi><mi>q</mi><mi>n</mi></msubsup><mo>→</mo><msub><mi mathvariant="double-struck">Z</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">f : \mathbb{Z}_q^n \to \mathbb{Z}_q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.072em;vertical-align:-0.3831em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.975em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>, and the input to the LWE problem is a sample of pairs <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\mathbf{x}, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi><mo>∈</mo><msubsup><mi mathvariant="double-struck">Z</mi><mi>q</mi><mi>n</mi></msubsup></mrow><annotation encoding="application/x-tex">\mathbf{x} \in \mathbb{Z}_q^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathbf">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.072em;vertical-align:-0.3831em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>∈</mo><msub><mi mathvariant="double-struck">Z</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">y \in \mathbb{Z}_q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.975em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>, so that with high probability <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y = f(\mathbf{x})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mclose">)</span></span></span></span>. Furthermore, the deviation from the equality is according to some known noise model. The problem calls for finding the function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>, or some close approximation thereof, with high probability.</p>
</div>

<p>This seems complex, but tbh, still better than other mathematical definitions for other stuff. One can get the idea from the above definition, that LWE problem is to find a solution to a set of linear equations with noise added to the system. Now, one might ask why this is hard to solve, proving that is out of scope for this blog, but for the curious who don’t fear a long mathematical detour, here you go: <a target="_blank" rel="noopener" href="https://arxiv.org/abs/1306.0281">Classical Hardness of LWE</a>.</p>
<h2 id="LWE-Encryption"><a href="#LWE-Encryption" class="headerlink" title="LWE Encryption"></a>LWE Encryption</h2><p>Now, that we know the crux of the problem, let’s jump straight into encryption using this problem.</p>
<p>So, an LWE ciphertext consists of a random public vector <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><msubsup><mi mathvariant="double-struck">Z</mi><mi>q</mi><mi>n</mi></msubsup></mrow><annotation encoding="application/x-tex">a \in \mathbb{Z}_q^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.072em;vertical-align:-0.3831em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em;"><span></span></span></span></span></span></span></span></span></span> and an additional element <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mi>a</mi><mo>⋅</mo><mi>s</mi><mo>+</mo><mi mathvariant="normal">Δ</mi><mo>⋅</mo><mi>m</mi><mo>+</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">b = a \cdot s + \Delta \cdot m + e </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> mod <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>. Let’s break this down further:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> is the **secret key**. Here, it is being randomly sampled from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mo stretchy="false">}</mo><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\{0, 1\}^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>.
</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> is the message. It is important to note that the message space has to be considerably small as compared to the integer ring <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">Z</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">\mathbb{Z}_q </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.975em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> in order to stop the ciphertext becoming random noise instead of encrypted data. In fact, we define another number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>, which is in general a power of 2. The power represents the number of bits required to represent any element from the message space.
</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span></span></span></span> is the scaling factor, which equals <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>q</mi><mi>p</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{q}{p} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2286em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>. So, by multiplying this scaling factor to our message, what is happening is, we are shifting the message bits to the most significant portions of an n bit structure.
</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> is the noise term and it is sampeled from a discrete Gaussian distribution with small standard distribution. Now, noise should not be too large that it affects the Most Significant Bits of the encoded message during the addition.</li>
</ul>
<h2 id="LWE-Decryption"><a href="#LWE-Decryption" class="headerlink" title="LWE Decryption"></a>LWE Decryption</h2><p>Decryption process is fairly simple. First, assuming that the receiver obviously has the secret key (NOTE: We have discussed the symmetric scheme here, it is also possible to devise an assymetric scheme usng LWE). The receiver will re-compute the dot product of the secret key and the public vector. Then, subtract the result from b. After that, perform an operation known as ROUND, which removes the error. Then we can just rescale the end result to get our decrypted plain-text.</p>
<p>Now that we are done with encryption and decryption using LWE, we can move forward having a look at the code and attacking strategies. I know that I have not explained the above concepts in a hurry cuz there are way better resources for studying about LWE, than here. So I would highly recommend checking out some blogs and papers online on LWE for a better understanding. I’ll also link some here:</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://www.jeremykun.com/2024/05/04/fhe-overview/#lwe-and-rlwe">Jeremy Kun’s Blog on FHE Overview</a>: He does a great job in explaining LWE and it’s sibling RLWE through words. Really good for an intuitive understanding. His other blogs are also very good and interesting. They cover crypto, signal processing. ML, Category Theory, and many more very interesting topics.</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=npoHSR6-oRw&t=5958s">TFHE Deep Dive talk by Ilaria chillotti</a>: It’s a really great talk for someone interested in getting into Homomorphic Encryption from mathematical perspective. Ilaria is one of the co-authors of the original TFHE (an FHE scheme) paper, and she does a great job explaining LWE, RLWE and RGSW.</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://web.stanford.edu/class/cs354/scribe/lecture14.pdf">Stanford Lecture on LWE</a>: For those serious about crypto. More math intensive, but more serious you are about crypto more you have to start dealing with rigrous abstract math.</p>
</li>
<li><p>Google, ChatGPT, Claude, what else do you want.</p>
</li>
</ul>
<h2 id="Code-which-we-are-going-to-BREAK"><a href="#Code-which-we-are-going-to-BREAK" class="headerlink" title="Code which we are going to BREAK"></a>Code which we are going to BREAK</h2><p>Now, let’s see the code which I will attempt to break. It encodes LWE encryption and decryption in a very naive manner or how I would imagine a person without a serious security team to code an LWE scheme. We’ll go block by block and you can find all the codes related to the blog in this <a target="_blank" rel="noopener" href="https://github.com/DA1729/breaking-lwe">repo</a>.</p>
<h3 id="Defining-the-parameters"><a href="#Defining-the-parameters" class="headerlink" title="Defining the parameters"></a>Defining the parameters</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> n = <span class="number">512</span>;           <span class="comment">// security parameter</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> q = <span class="number">12289</span>;         <span class="comment">// large prime modulus</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> p = <span class="number">4</span>;             <span class="comment">// message space &#123;0,1,2,3&#125;</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> delta = q / p;     <span class="comment">// scaling factor for encoding</span></span><br></pre></td></tr></table></figure>

<p>This is pretty self explanatory, just refer to the above definitions of the labeled terms, things will make sense. One thing to note, is that our message space is only <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{0, 1, 2, 3\} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mclose">}</span></span></span></span>, which might seem very impractical and something worth not break into. But trust me, give me a larger message space, I can either just scale my attack for these parameters, or not care as large message spaces don’t interact well with the added Gaussian noise. In other words, encryption is practically pure noise.</p>
<h3 id="Noise-sampling"><a href="#Noise-sampling" class="headerlink" title="Noise sampling"></a>Noise sampling</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// noise sampling</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sample_discrete_gaussian</span><span class="params">(std::mt19937&amp; gen, <span class="type">double</span> sigma = <span class="number">3.2</span>)</span> </span>&#123;</span><br><span class="line">    std::normal_distribution&lt;&gt; <span class="built_in">dist</span>(<span class="number">0.0</span>, sigma);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(std::<span class="built_in">round</span>(<span class="built_in">dist</span>(gen))) % q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here, a confusion might arise at the return statement. So the sample from a Gaussian distribution comes out as a double value in C++, but I want it to be an integer instead, NOO floating point headache. And, we really do want an “integer” sample from the distribution, and aditionally, it has to be in the ring <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">Z</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">\mathbb{Z}_q </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.975em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>, so I casted the double as an integer by first rounding it of course. Then I reduced it modulo <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>.</p>
<h3 id="Secret-key-generation"><a href="#Secret-key-generation" class="headerlink" title="Secret key generation"></a>Secret key generation</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// secret key</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">key_gen</span><span class="params">(std::mt19937&amp; gen)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">std::bernoulli_distribution <span class="title">bern</span><span class="params">(<span class="number">0.5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; si : s) si = <span class="built_in">bern</span>(gen);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Secret key, here, is just a vector of binary digits of length <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>. So, I just sampeled from a Bernoulli Distribution (with success probability equal to half), <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> times.</p>
<h3 id="Encryption"><a href="#Encryption" class="headerlink" title="Encryption"></a>Encryption</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// encryption</span></span><br><span class="line">std::pair&lt;std::vector&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt; <span class="built_in">encrypt</span>(<span class="type">int</span> m, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; s, std::mt19937&amp; gen) &#123;</span><br><span class="line">    std::uniform_int_distribution&lt;&gt; <span class="built_in">uniform_q</span>(<span class="number">0</span>, q - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; ai : a) ai = <span class="built_in">uniform_q</span>(gen);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> e = <span class="built_in">sample_discrete_gaussian</span>(gen);</span><br><span class="line">    <span class="type">int</span> b = (<span class="built_in">dot_mod_q</span>(a, s) + delta * m + e) % q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;a, b&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this function, we first sample the public vector of length <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>. Then things are pretty straight forward and matches one-on-one with the definitions above. Also, <code>dot_mod_q</code> ain’t a standard C++ function. It’s a function I wrote and did not explain in detail cuz it’s very simple to understand.</p>
<h3 id="Decryption"><a href="#Decryption" class="headerlink" title="Decryption"></a>Decryption</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decryption</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">decrypt</span><span class="params">(<span class="type">const</span> std::pair&lt;std::vector&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt;&amp; ct, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; a = ct.first;</span><br><span class="line">    <span class="type">int</span> b = ct.second;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> phase = (b - <span class="built_in">dot_mod_q</span>(a, s) + q) % q;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(std::<span class="built_in">round</span>((<span class="type">double</span>)phase / delta)) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this function, one can see the rounding step in the return statement. Rest, everything here too matches the one-on-one with the definitions above.</p>
<p>Now putting it all together, we have the following:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> n = <span class="number">512</span>;           <span class="comment">// security parameter</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> q = <span class="number">12289</span>;         <span class="comment">// large prime modulus</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> p = <span class="number">4</span>;             <span class="comment">// message space &#123;0,1,2,3&#125;</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> delta = q / p;     <span class="comment">// scaling factor for encoding</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// noise sampling</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sample_discrete_gaussian</span><span class="params">(std::mt19937&amp; gen, <span class="type">double</span> sigma = <span class="number">3.2</span>)</span> </span>&#123;</span><br><span class="line">    std::normal_distribution&lt;&gt; <span class="built_in">dist</span>(<span class="number">0.0</span>, sigma);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(std::<span class="built_in">round</span>(<span class="built_in">dist</span>(gen))) % q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// secret key</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">key_gen</span><span class="params">(std::mt19937&amp; gen)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">std::bernoulli_distribution <span class="title">bern</span><span class="params">(<span class="number">0.5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; si : s) si = <span class="built_in">bern</span>(gen);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dot_mod_q</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(a.<span class="built_in">size</span>() == b.<span class="built_in">size</span>());</span><br><span class="line">    <span class="type">int64_t</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        sum += <span class="built_in">static_cast</span>&lt;<span class="type">int64_t</span>&gt;(a[i]) * b[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(sum % q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// encryption</span></span><br><span class="line">std::pair&lt;std::vector&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt; <span class="built_in">encrypt</span>(<span class="type">int</span> m, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; s, std::mt19937&amp; gen) &#123;</span><br><span class="line">    std::uniform_int_distribution&lt;&gt; <span class="built_in">uniform_q</span>(<span class="number">0</span>, q - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; ai : a) ai = <span class="built_in">uniform_q</span>(gen);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> e = <span class="built_in">sample_discrete_gaussian</span>(gen);</span><br><span class="line">    <span class="type">int</span> b = (<span class="built_in">dot_mod_q</span>(a, s) + delta * m + e) % q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;a, b&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// decryption</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">decrypt</span><span class="params">(<span class="type">const</span> std::pair&lt;std::vector&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt;&amp; ct, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; a = ct.first;</span><br><span class="line">    <span class="type">int</span> b = ct.second;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> phase = (b - <span class="built_in">dot_mod_q</span>(a, s) + q) % q;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(std::<span class="built_in">round</span>((<span class="type">double</span>)phase / delta)) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::random_device rd;</span><br><span class="line">    <span class="function">std::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; s = <span class="built_in">key_gen</span>(gen);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Testing encryption over message space &#123;0,1,2,3&#125;:\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; p; ++m) &#123;</span><br><span class="line">        <span class="keyword">auto</span> ct = <span class="built_in">encrypt</span>(m, s, gen);</span><br><span class="line">        <span class="type">int</span> recovered = <span class="built_in">decrypt</span>(ct, s);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Original: &quot;</span> &lt;&lt; m</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; | Decrypted: &quot;</span> &lt;&lt; recovered</span><br><span class="line">                  &lt;&lt; ((m != recovered) ? <span class="string">&quot; ❌&quot;</span> : <span class="string">&quot; ✅&quot;</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And here is the output of the code:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Testing encryption over message space &#123;0,1,2,3&#125;:</span><br><span class="line">Original: 0 | Decrypted: 0 ✅</span><br><span class="line">Original: 1 | Decrypted: 1 ✅</span><br><span class="line">Original: 2 | Decrypted: 2 ✅</span><br><span class="line">Original: 3 | Decrypted: 3 ✅</span><br></pre></td></tr></table></figure>

<p>Ok, so now that we are done with the basics, now actually get into the main stuff. Breaking it.</p>
<h2 id="Cryptanalysis-of-Lazily-Coded-LWE"><a href="#Cryptanalysis-of-Lazily-Coded-LWE" class="headerlink" title="Cryptanalysis of Lazily Coded LWE"></a>Cryptanalysis of Lazily Coded LWE</h2><p>So before we dive into this interesting topic. Let’s make a few things clear.</p>
<ul>
<li><p>It is obvious that the code presented above is publicly available, owing to the <strong>Kerckhoff’s Principle</strong> which states that <strong>cryptosystem should be secure even if everything about the system, except the key, is public knowledge.</strong></p>
</li>
<li><p><strong>Access to ciphertexts</strong>: We assume a chosen-plaintext or known-plaintext scenario, meaning we either know the original message or can encrypt arbitrary messages and collect ciphertexts.</p>
</li>
<li><p><strong>Implementation-level behavior</strong>: We consider not just the mathematics, but also how the algorithm is implemented — which opens up potential side channels like timing variations or key reuse.</p>
</li>
<li><p><strong>Goal of cryptanalysis</strong>: We aim to recover the secret key <code>s</code>, distinguish ciphertexts from random noise, or infer plaintexts under various attack models, using practical and scalable methods — including statistical, lattice-based, and implementation-aware attacks.</p>
</li>
<li><p><strong>Math alert</strong>: I will go heavy on math at some places, cuz it would be necessary in the parts where we exploit the parameters selection for the system.</p>
</li>
</ul>
<p>Now let’s start with the method which includes less abstract maths.</p>
<h2 id="Machine-Learning-Attack"><a href="#Machine-Learning-Attack" class="headerlink" title="Machine Learning Attack"></a>Machine Learning Attack</h2><p>Now let’s start diving easy. I don’t wanna overwhelm anyone with loads of complex info. Let’s go easy and step by step. First, ML means training, which needs data. What will be the data?</p>
<h3 id="Data-generation"><a href="#Data-generation" class="headerlink" title="Data generation"></a>Data generation</h3><p>We, are collecting LWE samples which are tuples of the form: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="bold">a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>∈</mo><msubsup><mi mathvariant="double-struck">Z</mi><mi>q</mi><mi>n</mi></msubsup><mo>×</mo><msub><mi mathvariant="double-struck">Z</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">(\mathbf{a}, b) \in \mathbb{Z}_q^n \times \mathbb{Z}_q </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathbf">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.072em;vertical-align:-0.3831em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.975em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>, where each sample obviously follows:</p>
<p style="text-align:center;">
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mo stretchy="false">⟨</mo><mi mathvariant="bold">a</mi><mo separator="true">,</mo><mi mathvariant="bold">s</mi><mo stretchy="false">⟩</mo><mo>+</mo><mi>e</mi><mo>+</mo><mi mathvariant="normal">Δ</mi><mi>m</mi><mspace></mspace><mspace width="0.6667em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>q</mi></mrow><annotation encoding="application/x-tex">b = \langle \mathbf{a}, \mathbf{s} \rangle + e + \Delta m \mod q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathbf">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathbf">s</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span><span class="mord mathnormal">m</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>.
</p>

<p>Along with these tuples, we are also collecting the corresponding secret keys.</p>
<p>Now, for training purposes, we will only use the public vectors <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">a</mi></mrow><annotation encoding="application/x-tex">\mathbf{a} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"></span><span class="mord mathbf">a</span></span></span></span>s as the <strong>input vectors</strong> and the corresponding secret key bits as <strong>target-labels</strong>.</p>
<p>Analyzing the data we collected and the data we’ll use for the training, we can infer that we are casting this <strong>LWE secret key</strong> problem as a <strong>supervised classification task</strong>. Where, each bit position of the secret key is treated as a separate <strong>binary classification problem</strong>.</p>
<p>For those not so familiar with ML concepts (like me lol), <strong>supervised classification task</strong> is a task, where we have a <strong>labeled dataset</strong>: each input (feature vector) is mapped with the correct output <strong>label</strong>. And the goal is to <strong>train</strong> the model to learn mapping from input to labels, so it can classify <strong>new, unseen inputs</strong>. And <strong>binary classification</strong> means that output (lables) are from a finite set of two elements, 0 and 1 in our case.</p>
<p>Here, is the python code for data generation and preparation of the training data:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">n = <span class="number">512</span></span><br><span class="line">q = <span class="number">12289</span></span><br><span class="line">p = <span class="number">4</span></span><br><span class="line">delta = q // p</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lwe_data_generator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cpp_executable_path = <span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.cpp_code = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="string">#include &lt;vector&gt;</span></span><br><span class="line"><span class="string">#include &lt;random&gt;</span></span><br><span class="line"><span class="string">#include &lt;cmath&gt;</span></span><br><span class="line"><span class="string">#include &lt;cassert&gt;</span></span><br><span class="line"><span class="string">constexpr int n = 512;</span></span><br><span class="line"><span class="string">constexpr int q = 12289;</span></span><br><span class="line"><span class="string">constexpr int p = 4;</span></span><br><span class="line"><span class="string">constexpr int delta = q / p;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int sample_discrete_gaussian(std::mt19937&amp; gen, double sigma = 3.2) &#123;</span></span><br><span class="line"><span class="string">    std::normal_distribution&lt;&gt; dist(0.0, sigma);</span></span><br><span class="line"><span class="string">    return static_cast&lt;int&gt;(std::round(dist(gen))) % q;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">std::vector&lt;int&gt; key_gen(std::mt19937&amp; gen) &#123;</span></span><br><span class="line"><span class="string">    std::vector&lt;int&gt; s(n);</span></span><br><span class="line"><span class="string">    std::bernoulli_distribution bern(0.5);</span></span><br><span class="line"><span class="string">    for (int&amp; si : s) si = bern(gen);</span></span><br><span class="line"><span class="string">    return s;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int dot_mod_q(const std::vector&lt;int&gt;&amp; a, const std::vector&lt;int&gt;&amp; b) &#123;</span></span><br><span class="line"><span class="string">    assert(a.size() == b.size());</span></span><br><span class="line"><span class="string">    int64_t sum = 0;</span></span><br><span class="line"><span class="string">    for (size_t i = 0; i &lt; a.size(); ++i)</span></span><br><span class="line"><span class="string">        sum += static_cast&lt;int64_t&gt;(a[i]) * b[i];</span></span><br><span class="line"><span class="string">    return static_cast&lt;int&gt;(sum % q);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">std::pair&lt;std::vector&lt;int&gt;, int&gt; encrypt(int m, const std::vector&lt;int&gt;&amp; s, std::mt19937&amp; gen) &#123;</span></span><br><span class="line"><span class="string">    std::uniform_int_distribution&lt;&gt; uniform_q(0, q - 1);</span></span><br><span class="line"><span class="string">    std::vector&lt;int&gt; a(n);</span></span><br><span class="line"><span class="string">    for (int&amp; ai : a) ai = uniform_q(gen);</span></span><br><span class="line"><span class="string">    int e = sample_discrete_gaussian(gen);</span></span><br><span class="line"><span class="string">    int b = (dot_mod_q(a, s) + delta * m + e) % q;</span></span><br><span class="line"><span class="string">    return &#123;a, b&#125;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main() &#123;</span></span><br><span class="line"><span class="string">    std::random_device rd;</span></span><br><span class="line"><span class="string">    std::mt19937 gen(rd());</span></span><br><span class="line"><span class="string">    std::vector&lt;int&gt; s = key_gen(gen);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // Output secret key</span></span><br><span class="line"><span class="string">    std::cout &lt;&lt; &quot;SECRET:&quot;;</span></span><br><span class="line"><span class="string">    for (int si : s) std::cout &lt;&lt; &quot; &quot; &lt;&lt; si;</span></span><br><span class="line"><span class="string">    std::cout &lt;&lt; std::endl;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // Generate training samples</span></span><br><span class="line"><span class="string">    for (int i = 0; i &lt; 10000; ++i) &#123;</span></span><br><span class="line"><span class="string">        auto ct = encrypt(0, s, gen);  // Always encrypt 0 for key recovery</span></span><br><span class="line"><span class="string">        std::cout &lt;&lt; &quot;SAMPLE:&quot;;</span></span><br><span class="line"><span class="string">        for (int ai : ct.first) std::cout &lt;&lt; &quot; &quot; &lt;&lt; ai;</span></span><br><span class="line"><span class="string">        std::cout &lt;&lt; &quot; &quot; &lt;&lt; ct.second &lt;&lt; std::endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate_data</span>(<span class="params">self, num_samples = <span class="number">10000</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;generate lwe samples and secret key&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tempfile.NamedTemporaryFile(mode=<span class="string">&#x27;w&#x27;</span>, suffix=<span class="string">&#x27;.cpp&#x27;</span>, delete=<span class="literal">False</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(<span class="variable language_">self</span>.cpp_code)</span><br><span class="line">            cpp_file = f.name</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># compile</span></span><br><span class="line">            exe_file = cpp_file.replace(<span class="string">&#x27;.cpp&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            subprocess.run([<span class="string">&#x27;g++&#x27;</span>, <span class="string">&#x27;-o&#x27;</span>, exe_file, cpp_file], check=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># run and capture output</span></span><br><span class="line">            result = subprocess.run([exe_file], capture_output=<span class="literal">True</span>, text=<span class="literal">True</span>, check=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># parse output</span></span><br><span class="line">            lines = result.stdout.strip().split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># extract secret key</span></span><br><span class="line">            secret_line = [line <span class="keyword">for</span> line <span class="keyword">in</span> lines <span class="keyword">if</span> line.startswith(<span class="string">&#x27;SECRET:&#x27;</span>)][<span class="number">0</span>]</span><br><span class="line">            secret = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, secret_line.split()[<span class="number">1</span>:]))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># extract samples</span></span><br><span class="line">            sample_lines = [line <span class="keyword">for</span> line <span class="keyword">in</span> lines <span class="keyword">if</span> line.startswith(<span class="string">&#x27;SAMPLE:&#x27;</span>)]</span><br><span class="line">            samples = []</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> sample_lines:</span><br><span class="line">                parts = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, line.split()[<span class="number">1</span>:]))</span><br><span class="line">                a = parts[:-<span class="number">1</span>]  <span class="comment"># first n elements</span></span><br><span class="line">                b = parts[-<span class="number">1</span>]   <span class="comment"># last element</span></span><br><span class="line">                samples.append((a, b))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> np.array(secret), samples</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># cleanup</span></span><br><span class="line">            <span class="keyword">for</span> file <span class="keyword">in</span> [cpp_file, exe_file]:</span><br><span class="line">                <span class="keyword">if</span> os.path.exists(file):</span><br><span class="line">                    os.unlink(file)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_training_data</span>(<span class="params">secret, samples</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;convert LWE samples to ML training data&quot;&quot;&quot;</span></span><br><span class="line">    X = []  <span class="comment"># input vectors (a values)</span></span><br><span class="line">    y = []  <span class="comment"># target labels (secret bits)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> samples:</span><br><span class="line">        X.append(a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.array(X), np.array(secret)</span><br></pre></td></tr></table></figure>

<h3 id="Model-for-Single-Bit-Prediction"><a href="#Model-for-Single-Bit-Prediction" class="headerlink" title="Model for Single Bit Prediction"></a>Model for Single Bit Prediction</h3><p>Now, we construct a neural network for predicting a single bit of the secret key. First, let’s recall the fact that LWE encryption sample looks something like:</p>
<p style="text-align:center;">
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mo stretchy="false">⟨</mo><mi mathvariant="bold">a</mi><mo separator="true">,</mo><mi mathvariant="bold">s</mi><mo stretchy="false">⟩</mo><mo>+</mo><mi>e</mi><mo>+</mo><mi mathvariant="normal">Δ</mi><mi>m</mi><mspace></mspace><mspace width="0.6667em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>q</mi></mrow><annotation encoding="application/x-tex">b = \langle \mathbf{a}, \mathbf{s} \rangle + e + \Delta m \mod q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathbf">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathbf">s</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span><span class="mord mathnormal">m</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>.
</p>

<p>In out attack, the secret <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">s</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>s</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>s</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>s</mi><mn>511</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{s} = (s_0, s_1, \cdots, s_{511}) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"></span><span class="mord mathbf">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">511</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> is a 512-bit vector. The key idea is: <strong>can we learn the value of one secret bit <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> just from the vector <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">a</mi></mrow><annotation encoding="application/x-tex">\mathbf{a} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"></span><span class="mord mathbf">a</span></span></span></span></strong>. Another perspective, treat it like a classification problem-binary decision: is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn><mtext> or </mtext><mn>1</mn></mrow><annotation encoding="application/x-tex">s_i = 0 \text{ or } 1 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mord text"><span class="mord"> or </span></span><span class="mord">1</span></span></span></span>.</p>
<p>Now neural network (a fancy function approximator) takes in input values, and it learns to give the correct output through repeated training on examples.</p>
<p>In our case:</p>
<ul>
<li><strong>Input</strong>: the 512-dimension public vector from the LWE ciphertext.</li>
<li><strong>Output</strong>: prediction whether the secret bit is 0 or 1.</li>
</ul>
<p>To predict a single bit, we use a small feed-forward neural network. In other words, each layer passes its output to the next, in a simple pipelined manner.</p>
<p>Here’s how the network is structured:</p>
<table>
<thead>
<tr>
<th>Layer</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Input Layer</strong></td>
<td>Takes in the 512-length LWE vector <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">a</mi></mrow><annotation encoding="application/x-tex">\mathbf{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"></span><span class="mord mathbf">a</span></span></span></span></td>
</tr>
<tr>
<td><strong>Dense Layer (256 units)</strong></td>
<td>Fully connected to all input values, learns patterns</td>
</tr>
<tr>
<td><strong>Dropout (30%)</strong></td>
<td>Randomly disables some neurons during training to prevent overfitting</td>
</tr>
<tr>
<td><strong>Dense Layer (128 units)</strong></td>
<td>Learns more abstract features</td>
</tr>
<tr>
<td><strong>Dropout (30%)</strong></td>
<td>Again helps generalize</td>
</tr>
<tr>
<td><strong>Dense Layer (64 units)</strong></td>
<td>Further processing</td>
</tr>
<tr>
<td><strong>Output Layer (1 unit, sigmoid)</strong></td>
<td>Outputs a number between 0 and 1 representing probability that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">s_i = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td>
</tr>
</tbody></table>
<p>We train this model by feeding it:</p>
<ul>
<li>Thousands of LWE samples where the message is always 0.</li>
<li>The actual secret bit <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> corresponding to each sample.</li>
</ul>
<p>The model learns by adjusting internal weights to reduce the prediction errors. It utilizes:</p>
<ul>
<li><strong>Binary cross-entropy</strong>: a loss function for yes&#x2F;no predictions.</li>
<li><strong>Adam optimizer</strong>: a well-tuned optimizer that speeds up learning.</li>
<li><strong>Accuracy</strong>: to measure how often it correctly guesses the bit.</li>
</ul>
<p>Now don’t panic if you don’t understand much of these terms. I am also not an ML guy, and I had to do a lot of googling for getting these things down, I encourage you doing the same or just go with the flow with high level idea I presented for these things.</p>
<p>Anyways, the python code looks much shorter than the explanation :p</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_bit_model</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;neural network to predict one secret bit&quot;&quot;&quot;</span></span><br><span class="line">    model = keras.Sequential([</span><br><span class="line">        keras.layers.Dense(<span class="number">256</span>, activation = <span class="string">&#x27;relu&#x27;</span>, input_shape = (<span class="variable language_">self</span>.n)),</span><br><span class="line">        keras.layers.Dropout(<span class="number">0.3</span>),</span><br><span class="line">        keras.layers.Dense(<span class="number">128</span>, activation = <span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">        keras.layers.Dropout(<span class="number">0.3</span>),</span><br><span class="line">        keras.layers.Dense(<span class="number">64</span>, activation = <span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">        keras.layers.Dense(<span class="number">1</span>, activation = <span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    model.<span class="built_in">compile</span>(</span><br><span class="line">        optimizer = <span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">        loss = <span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">        metric = [<span class="string">&#x27;accuracy&#x27;</span>]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>

<p>The blog seems to be getting very big now. And I still have to train the model, which god knows if I’ll be able to do on my laptop or not. So let’s end this part here. See you very soon with part 2.</p>
<p>peace. da1729</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://da1729.github.io/2025/07/03/Breaking-LWE-Encryption/" data-id="cmcnwy0p10002f7bn7avd56sf" data-title="Breaking LWE Encryption Part 1" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cryptography/" rel="tag">Cryptography</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2025/04/16/Lottery-Ticket-Hypothesis-for-Beginners-Part-2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Lottery Ticket Hypothesis Part 2</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI-Acceleration/" rel="tag">AI - Acceleration</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI-Acceleration/" rel="tag">AI Acceleration</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Analog/" rel="tag">Analog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cryptography/" rel="tag">Cryptography</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hardware-Acceleration/" rel="tag">Hardware Acceleration</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VLSI/" rel="tag">VLSI</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AI-Acceleration/" style="font-size: 10px;">AI - Acceleration</a> <a href="/tags/AI-Acceleration/" style="font-size: 10px;">AI Acceleration</a> <a href="/tags/Analog/" style="font-size: 20px;">Analog</a> <a href="/tags/Cryptography/" style="font-size: 10px;">Cryptography</a> <a href="/tags/Hardware-Acceleration/" style="font-size: 20px;">Hardware Acceleration</a> <a href="/tags/VLSI/" style="font-size: 20px;">VLSI</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">July 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">April 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/07/03/Breaking-LWE-Encryption/">Breaking LWE Encryption Part 1</a>
          </li>
        
          <li>
            <a href="/2025/04/16/Lottery-Ticket-Hypothesis-for-Beginners-Part-2/">Lottery Ticket Hypothesis Part 2</a>
          </li>
        
          <li>
            <a href="/2025/04/13/Lottery-Ticket-Hypothesis-for-Beginners/">Lottery Ticket Hypothesis Part-1</a>
          </li>
        
          <li>
            <a href="/2025/03/18/In-Memory-Computation-using-Analog-Part-2/">In Memory Computation using Analog Part 2</a>
          </li>
        
          <li>
            <a href="/2025/03/15/In-Memory-Computation-using-Analog-Part-1/">In-Memory Computation using Analog Part-1</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Daksh Pandey<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>