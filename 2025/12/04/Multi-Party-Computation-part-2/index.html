<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Yao&#39;s Garbled Circuits | da1729&#39;s Blog</title>
  
  <!-- SEO Meta Tags -->
  <meta name="description" content="">
  <meta name="keywords" content="">
  <meta name="author" content="Daksh Pandey">
  
  <!-- Open Graph -->
  <meta property="og:title" content="Yao&#39;s Garbled Circuits">
  <meta property="og:description" content="">
  <meta property="og:type" content="post">
  <meta property="og:url" content="/2025/12/04/Multi-Party-Computation-part-2/">
  <meta property="og:site_name" content="da1729&#39;s Blog">
  
  <!-- CSS -->
  
<link rel="stylesheet" href="/css/style.css">

  
  <!-- RSS Feed -->
  
  
  <!-- Favicon -->
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div class="page-wrapper">
    <!-- Header -->
    <header class="header">
      <h1>
        <a href="/" class="site-title">da1729&#39;s Blog</a>
      </h1>
      
        <p class="site-subtitle">cryptography, digital design, embedded, rf, ...</p>
      
      
      <!-- Navigation -->
      <nav class="nav">
        
          <a href="/" class="nav-link">Home</a>
        
          <a href="/quick" class="nav-link">Quick Posts</a>
        
          <a href="/archives" class="nav-link">Archives</a>
        
          <a href="/about" class="nav-link">About</a>
        
        
        <!-- Social Links -->
        
          
            <a href="https://github.com/DA1729" class="nav-link" target="_blank" rel="noopener">github</a>
          
            <a href="https://x.com/sp0oky_daksh" class="nav-link" target="_blank" rel="noopener">twitter</a>
          
            <a href="mailto:dakshpandey177@gmail.com" class="nav-link" target="_blank" rel="noopener">email</a>
          
            <a href="https://sp0oky-portfolio.vercel.app/" class="nav-link" target="_blank" rel="noopener">portfolio</a>
          
        
      </nav>
    </header>

    <!-- Main Content -->
    <div class="container">
      <div class="content">
        <main class="main-content">
          <!-- Individual Post Page -->
<article class="article-card">
  <header class="article-header">
    <div class="article-meta">
      <time datetime="2025-12-03T19:03:28.000Z">
        December 4, 2025
      </time>
      
      
        <span> • Updated: December 4, 2025</span>
      
    </div>
    
    <h1 class="article-title">Yao&#39;s Garbled Circuits</h1>
    
    
      <div class="article-tags">
        
          <a href="/tags/Cryptography/" class="tag">#Cryptography</a>
        
          <a href="/tags/Secure-Computing/" class="tag">#Secure Computing</a>
        
      </div>
    
  </header>
  
  <div class="article-content">
    <div class="post-content">
      <p>Ok, let’s continue…</p>
<p>The major reference for this blog is “A Pragmatic Introduction to Secure Multi-Party Computation” by D. Evans, V. Kolesnikov, M. Rosulek.</p>
<hr>
<h2><span id="yao-s-garbled-circuits">Yao’s Garbled Circuits</span></h2><p>Let’s set the ground first. We wish to evaluate the function $\mathcal{F}(x, y)$, where party $P_1$ holds $x \in X$ and second party $P_2$ holds $y \in Y$, where $X$ and $Y$ are respective domains for the inputs from the corresponding party (node).</p>
<p>Yao’s Garbled Circuits (GC) is basically the celebrity of MPC. It is historically significant and usually the go-to performance benchmark. The killer feature here is that it runs in <strong>constant rounds</strong>. Unlike other protocols (like GMW) where network latency kills you because communication rounds scale with the circuit depth, Yao’s GC essentially lets you send the whole “computer” over the wire in one go.</p>
<h3><span id="gc-intuition-the-look-up-table">GC Intuition: The Look-up Table</span></h3><p>Imagine our function $\mathcal{F}$ has a tiny input domain. We could literally just write down every possible result in a table $T$ where rows are indexed by $(x, y)$.</p>
<p>To make this secure, $P_1$ (the generator) creates random keys. For every possible input $x$, they generate a key $k_x$. For every $y$, a key $k_y$. Then, they encrypt the answer $T_{x,y}$ using those two keys.<br>$$\text{Enc}_{k_x, k_y}(T_{x,y})$$<br>$P_1$ shuffles this table randomly and sends it to $P_2$. Now, if $P_2$ can somehow get the specific keys corresponding to the actual inputs, they can decrypt exactly one row and get the answer. They learn nothing else because they don’t have the keys for the other rows.</p>
<p>Here is how a basic entry encryption might look in c++:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">table_entry</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">uint8_t</span>&gt; encrypted_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">table_entry <span class="title">encrypt_row</span><span class="params">(std::string k_x, std::string k_y, std::string value)</span> </span>&#123;</span><br><span class="line">    std::string combined_key = <span class="built_in">hash</span>(k_x + k_y);</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="built_in">xor_encrypt</span>(value, combined_key) &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="point-and-permute">Point-and-Permute</span></h3><p>If $P_1$ just sends a shuffled bag of encrypted rows, $P_2$ has a problem. They have two keys, but they don’t know which row those keys open. Trying to decrypt every single row is inefficient (especially when we scale up).</p>
<p>The solution is <strong>point-and-permute</strong>. We append a random “pointer bit” (let’s call it $\sigma$) to the keys.<br>If we have a key $k$, the last bit is the pointer. When $P_1$ generates the keys, they ensure the pointer bits don’t collide. Now, $P_2$ looks at the pointer bit of their $x$-key and $y$-key (say, $0$ and $1$) and knows exactly that they need to decrypt the row indexed $0,1$ in the permuted table.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">wire_label</span> &#123;</span><br><span class="line">    std::string key;</span><br><span class="line">    <span class="type">uint8_t</span> pointer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">garbled_table</span> &#123;</span><br><span class="line">    std::vector&lt;std::vector&lt;std::string&gt;&gt; rows;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">garbled_table <span class="title">create_table</span><span class="params">(<span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    garbled_table t;</span><br><span class="line">    t.rows.<span class="built_in">resize</span>(size, std::<span class="built_in">vector</span>&lt;std::string&gt;(size));</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_entry</span><span class="params">(garbled_table&amp; t, wire_label lx, wire_label ly, std::string enc_val)</span> </span>&#123;</span><br><span class="line">    t.rows[lx.pointer][ly.pointer] = enc_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="managing-table-size-the-circuit-view">Managing Table Size: The Circuit View</span></h3><p>Obviously, a giant look-up table for complex functions is impossible. It scales exponentially. So, we represent the function $\mathcal{F}$ as a <strong>Boolean Circuit</strong>.</p>
<p>Instead of one giant table, we have many tiny tables—one for each logic gate (AND, OR, XOR).<br>For every wire $w_i$ in the circuit, $P_1$ generates two keys: $k_i^0$ (representing 0) and $k_i^1$ (representing 1). We call these <strong>wire labels</strong>.</p>
<p>For a gate $G$ with input wires $w_i, w_j$ and output wire $w_t$, $P_1$ creates a table with 4 entries. The entry for input combination $(v_i, v_j)$ encrypts the output label $k_t^{G(v_i, v_j)}$.</p>
<p>$$T_G &#x3D; \begin{pmatrix} \text{Enc}_{k_i^0, k_j^0}(k_t^{G(0,0)}) \\ \text{Enc}_{k_i^0, k_j^1}(k_t^{G(0,1)}) \\ \text{Enc}_{k_i^1, k_j^0}(k_t^{G(1,0)}) \\ \text{Enc}_{k_i^1, k_j^1}(k_t^{G(1,1)}) \end{pmatrix}$$</p>
<p>Crucially, the “message” inside the encryption is the <em>key</em> for the next wire. This allows $P_2$ to chain decryptions through the circuit without ever knowing if they are holding a logical 0 or 1. They just hold keys.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">gate</span> &#123;</span><br><span class="line">    std::string encrypted_outputs[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">gate <span class="title">garble_and_gate</span><span class="params">(wire_label in_a[<span class="number">2</span>], wire_label in_b[<span class="number">2</span>], wire_label out[<span class="number">2</span>])</span> </span>&#123;</span><br><span class="line">    gate g;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> res = i &amp; j;</span><br><span class="line">            std::string key = <span class="built_in">hash</span>(in_a[i].key + in_b[j].key);</span><br><span class="line">            g.encrypted_outputs[in_a[i].pointer][in_b[j].pointer] = </span><br><span class="line">                <span class="built_in">xor_encrypt</span>(out[res].key, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="the-protocol-flow">The Protocol Flow</span></h3><p>So how does the actual exchange happen?</p>
<ol>
<li><strong>Garbling</strong>: $P_1$ (Generator) creates the circuit topology, generates all wire labels, and builds the garbled tables for every gate.</li>
<li><strong>Sending Tables</strong>: $P_1$ sends all garbled tables to $P_2$.</li>
<li><strong>Sending Keys (P1’s Input)</strong>: $P_1$ knows their own input $x$. If the $i$-th bit of $x$ is 1, they just send the label $k_i^1$ to $P_2$.</li>
<li><strong>Sending Keys (P2’s Input)</strong>: This is tricky. $P_1$ has the labels for $P_2$’s input wires, but doesn’t know $P_2$’s input $y$. $P_2$ needs the labels but shouldn’t tell $P_1$ their input $y$. We use <strong>Oblivious Transfer (OT)</strong> here. $P_2$ receives the correct labels for their input without revealing $y$ to $P_1$.</li>
<li><strong>Evaluation</strong>: $P_2$ now has the tables and the input wire labels. They go gate by gate, decrypting one entry per gate to get the output label, until they reach the end.</li>
<li><strong>Decryption</strong>: For the final output wires, $P_1$ provides a mapping (decoding table) so $P_2$ can map the final random string back to a True&#x2F;False.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">evaluator_step</span><span class="params">(gate g, wire_label wa, wire_label wb)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> idx_a = wa.pointer;</span><br><span class="line">    <span class="type">int</span> idx_b = wb.pointer;</span><br><span class="line">    </span><br><span class="line">    std::string ciphertext = g.encrypted_outputs[idx_a][idx_b];</span><br><span class="line">    std::string combined_key = <span class="built_in">hash</span>(wa.key + wb.key);</span><br><span class="line">    </span><br><span class="line">    std::string output_key = <span class="built_in">xor_decrypt</span>(ciphertext, combined_key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Security relies on the fact that $P_2$ never possesses both $k^0$ and $k^1$ for the same wire simultaneously. If they did, they could decrypt everything. But since they only start with one set of keys and only recover one key per gate, the invariant holds.</p>
<p>There are massive optimizations for this, like “Free XOR” and “Half Gates” which drastically reduce the size of these tables, but that’s for another post.</p>
<hr>
<p>peace. da1729</p>

    </div>
  </div>
</article>

<!-- Post Navigation -->

  <nav class="post-nav mt-2">
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
      
        <div class="widget">
          <div class="widget-title">Previous Post</div>
          <a href="/2025/12/04/Gentry-Lee-Encoding-for-Efficient-Matrix-FHE/">Gentry-Lee Encoding for Efficient Matrix FHE</a>
        </div>
      
      
      
        <div class="widget">
          <div class="widget-title">Next Post</div>
          <a href="/2025/12/01/Multi-Party-Computation/">Multi-Party Computation part 1</a>
        </div>
      
    </div>
  </nav>


<!-- Related Posts -->

        </main>
        
        <!-- Sidebar -->
        <aside class="sidebar">
          <!-- Sidebar Widgets -->

<!-- Recent Posts Widget -->

  <div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <ul>
      
        <li>
          <a href="/2025/12/06/MPC-in-the-Head-MPCitH/">MPC in the Head (MPCitH)</a>
          <div style="font-size: 0.8em; color: var(--text-secondary); margin-top: 4px;">
            Dec 6, 2025
          </div>
        </li>
      
        <li>
          <a href="/2025/12/04/Gentry-Lee-Encoding-for-Efficient-Matrix-FHE/">Gentry-Lee Encoding for Efficient Matrix FHE</a>
          <div style="font-size: 0.8em; color: var(--text-secondary); margin-top: 4px;">
            Dec 4, 2025
          </div>
        </li>
      
        <li>
          <a href="/2025/12/04/Multi-Party-Computation-part-2/">Yao&#39;s Garbled Circuits</a>
          <div style="font-size: 0.8em; color: var(--text-secondary); margin-top: 4px;">
            Dec 4, 2025
          </div>
        </li>
      
        <li>
          <a href="/2025/12/01/Multi-Party-Computation/">Multi-Party Computation part 1</a>
          <div style="font-size: 0.8em; color: var(--text-secondary); margin-top: 4px;">
            Dec 1, 2025
          </div>
        </li>
      
        <li>
          <a href="/2025/09/27/Need-for-Gadget-Decomposition-in-LWE-Based-Cryptosystems/">Need for Gadget Decomposition in LWE Based Cryptosystems</a>
          <div style="font-size: 0.8em; color: var(--text-secondary); margin-top: 4px;">
            Sep 27, 2025
          </div>
        </li>
      
    </ul>
  </div>


<!-- Categories Widget -->


<!-- Tags Widget -->

  <div class="widget">
    <h3 class="widget-title">Tags</h3>
    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
      
        <a href="/tags/AI-Acceleration/" class="tag">
          #AI - Acceleration
        </a>
      
        <a href="/tags/AI-Acceleration/" class="tag">
          #AI Acceleration
        </a>
      
        <a href="/tags/Abstract-Algebra/" class="tag">
          #Abstract Algebra
        </a>
      
        <a href="/tags/Analog/" class="tag">
          #Analog
        </a>
      
        <a href="/tags/Cryptanalysis/" class="tag">
          #Cryptanalysis
        </a>
      
        <a href="/tags/Cryptography/" class="tag">
          #Cryptography
        </a>
      
        <a href="/tags/Fully-Homomorphic-Encryption/" class="tag">
          #Fully Homomorphic Encryption
        </a>
      
        <a href="/tags/Hardware-Acceleration/" class="tag">
          #Hardware Acceleration
        </a>
      
        <a href="/tags/Philosphy/" class="tag">
          #Philosphy
        </a>
      
        <a href="/tags/Post-Quantum-Cryptography/" class="tag">
          #Post Quantum Cryptography
        </a>
      
        <a href="/tags/Post-Quantum-Cryptography/" class="tag">
          #Post-Quantum Cryptography
        </a>
      
        <a href="/tags/Ring-Theory/" class="tag">
          #Ring Theory
        </a>
      
        <a href="/tags/Secure-Computing/" class="tag">
          #Secure Computing
        </a>
      
        <a href="/tags/VLSI/" class="tag">
          #VLSI
        </a>
      
        <a href="/tags/Zero-Knowledge/" class="tag">
          #Zero-Knowledge
        </a>
      
    </div>
  </div>


<!-- Archive Widget -->

  <div class="widget">
    <h3 class="widget-title">Archive</h3>
    <ul>
      
      
        
          <li>
            <a href="/archives/2025/">
              December 2025 (4)
            </a>
          </li>
        
          <li>
            <a href="/archives/2025/">
              September 2025 (2)
            </a>
          </li>
        
          <li>
            <a href="/archives/2025/">
              August 2025 (1)
            </a>
          </li>
        
          <li>
            <a href="/archives/2025/">
              July 2025 (1)
            </a>
          </li>
        
          <li>
            <a href="/archives/2025/">
              April 2025 (2)
            </a>
          </li>
        
          <li>
            <a href="/archives/2025/">
              March 2025 (2)
            </a>
          </li>
        
      
    </ul>
  </div>


<!-- About Widget -->
<div class="widget">
  <h3 class="widget-title">About</h3>
  <p style="font-size: 0.9em; line-height: 1.6;">
    Welcome to my blog! Here I write about various topics including technology, programming, and more.
  </p>
  
  
    <div style="margin-top: 15px;">
      <strong style="font-size: 0.9em;">Find me on:</strong>
      <div style="margin-top: 8px; display: flex; flex-wrap: wrap; gap: 8px;">
        
          <a href="https://github.com/DA1729" class="tag" target="_blank" rel="noopener">
            github
          </a>
        
          <a href="https://x.com/sp0oky_daksh" class="tag" target="_blank" rel="noopener">
            twitter
          </a>
        
          <a href="mailto:dakshpandey177@gmail.com" class="tag" target="_blank" rel="noopener">
            email
          </a>
        
          <a href="https://sp0oky-portfolio.vercel.app/" class="tag" target="_blank" rel="noopener">
            portfolio
          </a>
        
      </div>
    </div>
  
  
  <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color);">
    <p style="font-size: 0.8em; color: var(--text-secondary); opacity: 0.8;">
      Theme designed with 
      <a href="https://claude.ai/code" target="_blank" rel="noopener" style="color: var(--link-color); text-decoration: none;">Claude Code</a>
    </p>
  </div>
</div>
        </aside>
      </div>
    </div>

    <!-- Footer -->
    <footer class="footer">
      <p>© 2025 Daksh Pandey. Portfolio-inspired theme crafted with Claude Code.</p>
    </footer>
  </div>

  <!-- JavaScript -->
  
<script src="/js/main.js"></script>

  
  <!-- Math Support -->
  
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          ignoreHtmlClass: 'tex2jax_ignore',
          processHtmlClass: 'tex2jax_process'
        }
      };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  
</body>
</html>