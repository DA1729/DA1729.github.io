<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ring-LWE and CKKS: Mathematical Foundations for Homomorphic Encryption | da1729&#39;s Blog</title>
  
  <!-- SEO Meta Tags -->
  <meta name="description" content="">
  <meta name="keywords" content="">
  <meta name="author" content="Daksh Pandey">
  
  <!-- Open Graph -->
  <meta property="og:title" content="Ring-LWE and CKKS: Mathematical Foundations for Homomorphic Encryption">
  <meta property="og:description" content="">
  <meta property="og:type" content="post">
  <meta property="og:url" content="/2025/08/15/Ring-LWE-and-CKKS-Mathematical-Foundations/">
  <meta property="og:site_name" content="da1729&#39;s Blog">
  
  <!-- CSS -->
  
<link rel="stylesheet" href="/css/style.css">

  
  <!-- RSS Feed -->
  
  
  <!-- Favicon -->
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div class="page-wrapper">
    <!-- Header -->
    <header class="header">
      <h1>
        <a href="/" class="site-title">da1729&#39;s Blog</a>
      </h1>
      
        <p class="site-subtitle">cryptography, digital design, embedded, rf, ...</p>
      
      
      <!-- Navigation -->
      <nav class="nav">
        
          <a href="/" class="nav-link">Home</a>
        
          <a href="/quick" class="nav-link">Quick Posts</a>
        
          <a href="/archives" class="nav-link">Archives</a>
        
          <a href="/about" class="nav-link">About</a>
        
        
        <!-- Social Links -->
        
          
            <a href="https://github.com/DA1729" class="nav-link" target="_blank" rel="noopener">github</a>
          
            <a href="https://x.com/sp0oky_daksh" class="nav-link" target="_blank" rel="noopener">twitter</a>
          
            <a href="mailto:dakshpandey177@gmail.com" class="nav-link" target="_blank" rel="noopener">email</a>
          
            <a href="https://sp0oky-portfolio.vercel.app/" class="nav-link" target="_blank" rel="noopener">portfolio</a>
          
        
      </nav>
    </header>

    <!-- Main Content -->
    <div class="container">
      <div class="content">
        <main class="main-content">
          <!-- Individual Post Page -->
<article class="article-card">
  <header class="article-header">
    <div class="article-meta">
      <time datetime="2025-08-15T09:00:00.000Z">
        August 15, 2025
      </time>
      
      
        <span> • Updated: September 27, 2025</span>
      
    </div>
    
    <h1 class="article-title">Ring-LWE and CKKS: Mathematical Foundations for Homomorphic Encryption</h1>
    
    
      <div class="article-tags">
        
          <a href="/tags/Abstract-Algebra/" class="tag">#Abstract Algebra</a>
        
          <a href="/tags/Fully-Homomorphic-Encryption/" class="tag">#Fully Homomorphic Encryption</a>
        
          <a href="/tags/Cryptography/" class="tag">#Cryptography</a>
        
          <a href="/tags/Post-Quantum-Cryptography/" class="tag">#Post Quantum Cryptography</a>
        
          <a href="/tags/Ring-Theory/" class="tag">#Ring Theory</a>
        
      </div>
    
  </header>
  
  <div class="article-content">
    <div class="post-content">
      <p>Alright, so I’ve been diving deep into the mathematical foundations behind modern FHE schemes, and honestly, the more I understand the underlying algebra, the more elegant this whole thing becomes. In my previous blog on LWE cryptanalysis, I touched on the basic Learning With Errors problem, but now I want to get into the real mathematical meat of Ring-LWE and the CKKS scheme.</p>
<p>This is gonna be pretty heavy on the math - we’re talking cyclotomic polynomials, Galois theory, Chinese Remainder Theorem, and some serious algebraic number theory. But stick with me, cuz understanding this foundation is crucial for grasping how modern FHE schemes actually work under the hood.</p>
<span id="more"></span>

<p>I’m writing this as a mathematical foundation piece because I realized that in my upcoming blogs on automorphisms and key switching, I keep having to explain these core concepts. So here’s the deep mathematical dive that’ll serve as the foundation for those more specialized topics.</p>
<h2><span id="table-of-contents">Table of Contents</span></h2><ul>
<li><a href="#from-lwe-to-ring-lwe-why-rings">From LWE to Ring-LWE: Why Rings?</a></li>
<li><a href="#cyclotomic-polynomials-and-algebraic-structure">Cyclotomic Polynomials and Algebraic Structure</a></li>
<li><a href="#the-chinese-remainder-theorem-perspective">The Chinese Remainder Theorem Perspective</a></li>
<li><a href="#ckks-encoding-complex-numbers-in-polynomials">CKKS Encoding: Complex Numbers in Polynomials</a></li>
<li><a href="#discrete-gaussian-distributions-and-noise">Discrete Gaussian Distributions and Noise</a></li>
<li><a href="#security-foundations-ideal-lattices">Security Foundations: Ideal Lattices</a></li>
<li><a href="#parameter-selection-and-trade-offs">Parameter Selection and Trade-offs</a></li>
<li><a href="#implementation-considerations">Implementation Considerations</a></li>
<li><a href="#references">References</a></li>
</ul>
<h2><span id="from-lwe-to-ring-lwe-why-rings">From LWE to Ring-LWE: Why Rings?</span></h2><p>So we all know that standard LWE works with vectors in $\mathbb{Z}_q^n$. An LWE sample looks like $(\mathbf{a}, b)$ where $b &#x3D; \langle \mathbf{a}, \mathbf{s} \rangle + e + \Delta m$. This is great and all, but there are some serious practical issues:</p>
<ol>
<li><strong>Key Size</strong>: The secret key $\mathbf{s}$ has $n$ elements</li>
<li><strong>Ciphertext Size</strong>: Each ciphertext is $(n+1)$ elements</li>
<li><strong>Operations</strong>: Matrix-vector multiplications are expensive</li>
</ol>
<p>Ring-LWE fixes this by moving from vectors to polynomials. Instead of working in $\mathbb{Z}_q^n$, we work in the polynomial ring $R_q &#x3D; \mathbb{Z}_q[X]&#x2F;(f(X))$ for some polynomial $f(X)$.</p>
<p>Now here’s the key insight: <strong>a polynomial of degree $n-1$ can be represented by $n$ coefficients, just like a vector of length $n$</strong>. But polynomial arithmetic gives us way more structure to work with.</p>
<p>A Ring-LWE sample looks like:</p>
<p style="text-align:center;">
$(a(X), b(X)) \text{ where } b(X) = a(X) \cdot s(X) + e(X) + \Delta \cdot m(X) \bmod f(X)$
</p>

<p>The magic happens because polynomial multiplication in $R_q$ can be done super efficiently using Number Theoretic Transform (NTT), which is basically FFT over finite fields.</p>
<h2><span id="cyclotomic-polynomials-and-algebraic-structure">Cyclotomic Polynomials and Algebraic Structure</span></h2><p>Now, the choice of $f(X)$ is crucial. We typically use $f(X) &#x3D; X^n + 1$ where $n$ is a power of 2. This isn’t random - $X^n + 1$ is the $2n$-th cyclotomic polynomial $\Phi_{2n}(X)$.</p>
<h3><span id="what-are-cyclotomic-polynomials">What are Cyclotomic Polynomials?</span></h3><p>Think of cyclotomic polynomials as the <strong>“primes” of polynomial rings</strong>. Just like how prime numbers are the indivisible building blocks of integers, cyclotomic polynomials are irreducible polynomials that can’t be factored further over the rationals.</p>
<p>But here’s the cool part - while prime numbers feel abstract and random, cyclotomic polynomials have this beautiful geometric interpretation. The $m$-th cyclotomic polynomial $\Phi_m(X)$ “knows about” the $m$-sided regular polygon!</p>
<h3><span id="visualizing-the-geometric-picture">Visualizing the Geometric Picture</span></h3><p>Imagine you’re standing at the center of a circle, looking at the vertices of a regular $2n$-sided polygon inscribed in that circle. Each vertex corresponds to a $2n$-th root of unity - a complex number $\zeta_{2n}^k &#x3D; e^{2\pi i k &#x2F; 2n}$.</p>
<p>Now, most of these vertices are “derived” - if you know where vertex 1 is, you can get vertex 2 by just squaring it, vertex 3 by cubing it, etc. But some vertices are <strong>primitive</strong> - they can’t be obtained as powers of vertices from smaller polygons.</p>
<p>The cyclotomic polynomial $\Phi_{2n}(X)$ is exactly the polynomial whose roots are these primitive vertices!</p>
<p>For our specific case where $m &#x3D; 2n$ and $n$ is a power of 2:</p>
<p style="text-align:center;">
$\Phi_{2n}(X) = X^n + 1$
</p>

<p>The primitive $2n$-th roots of unity are exactly the <strong>odd powers</strong>: ${\zeta_{2n}, \zeta_{2n}^3, \zeta_{2n}^5, \ldots, \zeta_{2n}^{2n-1}}$.</p>
<p>Why odd powers? Because if $k$ is even, then $\zeta_{2n}^k &#x3D; (\zeta_{n})^{k&#x2F;2}$ is actually an $n$-th root of unity, so it “belongs” to a smaller polygon!</p>
<h3><span id="the-ring-structure-why-x-n-x3d-1-is-magic">The Ring Structure: Why $X^n &#x3D; -1$ is Magic</span></h3><p>Working in $R &#x3D; \mathbb{Z}[X]&#x2F;(X^n + 1)$ means we’re doing polynomial arithmetic with the rule that $X^n &#x3D; -1$. This seems weird at first, but it’s actually brilliant!</p>
<p>Think of it this way: in regular polynomial multiplication, if you multiply two polynomials of degree $d$, you get a polynomial of degree $2d$. That’s annoying for storage - your polynomials keep getting bigger.</p>
<p>But with the rule $X^n &#x3D; -1$, any polynomial automatically “wraps around” to stay within degree $n-1$. It’s like doing arithmetic on a clock, but instead of $12 + 1 &#x3D; 1$, we have $X^n &#x3D; -1$.</p>
<p>Here’s the intuition for why it’s $-1$ and not $0$: remember those primitive $2n$-th roots of unity? They satisfy $\zeta^{2n} &#x3D; 1$, which means $(\zeta^n)^2 &#x3D; 1$. Since $\zeta^n \neq 1$ (that would make it an $n$-th root), we must have $\zeta^n &#x3D; -1$.</p>
<p>The beautiful structure we get:</p>
<ol>
<li><strong>Wrapping Multiplication</strong>: $X^i \cdot X^j &#x3D; X^{(i+j) \bmod n}$ if $i+j &lt; n$, otherwise $X^i \cdot X^j &#x3D; -X^{(i+j) \bmod n}$</li>
<li><strong>FFT-Friendly</strong>: The Number Theoretic Transform works perfectly because our roots of unity are evenly spaced around the circle</li>
<li><strong>Lattice Structure</strong>: The ring elements correspond to lattice points with special geometric properties</li>
</ol>
<p>The automorphism group is isomorphic to $(\mathbb{Z}&#x2F;2n\mathbb{Z})^*$, which has order $n$. Each automorphism $\sigma_k$ is defined by $\sigma_k: X \mapsto X^k$ where $\gcd(k, 2n) &#x3D; 1$.</p>
<h2><span id="the-chinese-remainder-theorem-perspective">The Chinese Remainder Theorem Perspective</span></h2><p>This is where the magic really happens, and it’s the key insight that makes CKKS so powerful. Let me give you the intuition first, then the math.</p>
<h3><span id="the-multiple-personalities-view">The “Multiple Personalities” View</span></h3><p>Imagine you have a polynomial $p(X)$. Instead of thinking of it as a single mathematical object, the Chinese Remainder Theorem says you can think of it as having $n$ different “personalities” - one for each root of $X^n + 1$.</p>
<p>It’s like how Clark Kent and Superman are the same person, just in different contexts. Your polynomial $p(X)$ is “the same” as the vector $(p(\zeta_1), p(\zeta_2), \ldots, p(\zeta_n))$ where the $\zeta_i$ are the roots of $X^n + 1$.</p>
<p>Mathematically, this gives us an isomorphism:</p>
<p style="text-align:center;">
$\mathbb{C}[X]/(X^n + 1) \cong \mathbb{C}^n$
</p>

<p>Any polynomial $p(X) \in \mathbb{C}[X]&#x2F;(X^n + 1)$ is uniquely determined by its evaluations:</p>
<p style="text-align:center;">
$p(X) \leftrightarrow (p(\zeta_{2n}), p(\zeta_{2n}^3), \ldots, p(\zeta_{2n}^{2n-1}))$
</p>

<h3><span id="why-this-is-revolutionary-for-computation">Why This is Revolutionary for Computation</span></h3><p>Here’s the killer insight: <strong>polynomial operations become pointwise vector operations</strong>!</p>
<p>Want to add two polynomials? Just add their evaluation vectors component-wise. Want to multiply? Multiply component-wise. This is called <strong>SIMD (Single Instruction, Multiple Data)</strong> - you get $n$ operations for the price of one.</p>
<h3><span id="complex-conjugate-pairs-the-ckks-packing-trick">Complex Conjugate Pairs: The CKKS Packing Trick</span></h3><p>Here’s where CKKS gets really clever. Remember our $2n$-sided polygon? The vertices come in <strong>conjugate pairs</strong> - if you have a vertex at angle $\theta$, you also have one at angle $-\theta$.</p>
<p>This means if $\zeta$ is a root of $X^n + 1$, then so is $\overline{\zeta}$ (its complex conjugate).</p>
<p>Now here’s the packing magic: if we restrict to polynomials with <strong>real coefficients</strong> (which is what we do in practice), then evaluating our polynomial at conjugate pairs gives conjugate values:</p>
<p style="text-align:center;">
$p(\zeta) = \overline{p(\overline{\zeta})}$
</p>

<p>This means we only need to store <strong>half</strong> the evaluation vector! If we know $p(\zeta)$, we automatically know $p(\overline{\zeta}) &#x3D; \overline{p(\zeta)}$.</p>
<p><strong>Result</strong>: We can pack $n&#x2F;2$ complex numbers into a single polynomial of degree $n-1$. It’s like getting a 2x compression for free, just by exploiting the symmetry of the roots!</p>
<h2><span id="ckks-encoding-complex-numbers-in-polynomials">CKKS Encoding: Complex Numbers in Polynomials</span></h2><p>The CKKS scheme exploits this conjugate structure beautifully. Think of it as a universal translator between two languages: the language of polynomials and the language of complex vectors.</p>
<h3><span id="the-encoding-intuition">The Encoding Intuition</span></h3><p>Imagine you have $n&#x2F;2$ complex numbers that represent, say, the pixels of an image or the coefficients of a Fourier transform. You want to encrypt them homomorphically, but Ring-LWE only knows how to encrypt polynomials.</p>
<p>CKKS says: “No problem! I’ll convert your complex vector into a polynomial, encrypt that polynomial, and when you do operations on the polynomial, they’ll automatically happen to your original complex numbers.”</p>
<p>It’s like having a magical box where you put in a complex vector, it gets converted to a polynomial, encrypted, and when you add two such boxes, the encrypted polynomials add in a way that makes the underlying complex vectors add too.</p>
<h3><span id="canonical-embedding-the-universal-translator">Canonical Embedding: The Universal Translator</span></h3><p>The <strong>canonical embedding</strong> $\sigma$ is our universal translator. It takes a polynomial $p(X) &#x3D; \sum_{i&#x3D;0}^{n-1} p_i X^i$ and evaluates it at all our special roots:</p>
<p style="text-align:center;">
$\sigma(p) = (p(\zeta_{2n}), p(\zeta_{2n}^3), \ldots, p(\zeta_{2n}^{2n-1}))$
</p>

<p>This is like asking: “If this polynomial were a person, what would it say when you ask it about each of these $n$ roots?”</p>
<h3><span id="encoding-complex-vectors">Encoding Complex Vectors</span></h3><p>To encode a vector $\mathbf{z} &#x3D; (z_0, z_1, \ldots, z_{n&#x2F;2-1}) \in \mathbb{C}^{n&#x2F;2}$, we:</p>
<ol>
<li><strong>Extend to Conjugates</strong>: Create $\tilde{\mathbf{z}} &#x3D; (z_0, \ldots, z_{n&#x2F;2-1}, \overline{z_{n&#x2F;2-1}}, \ldots, \overline{z_0}) \in \mathbb{C}^n$</li>
<li><strong>Inverse Canonical Embedding</strong>: Compute $p &#x3D; \sigma^{-1}(\tilde{\mathbf{z}})$</li>
<li><strong>Scaling and Rounding</strong>: Scale by $\Delta$ and round to get integer coefficients</li>
</ol>
<p>The inverse canonical embedding can be computed efficiently using the <strong>Vandermonde matrix</strong>:</p>
<p style="text-align:center;">
$V = \begin{pmatrix}
1 & \zeta_{2n} & \zeta_{2n}^2 & \cdots & \zeta_{2n}^{n-1} \\
1 & \zeta_{2n}^3 & (\zeta_{2n}^3)^2 & \cdots & (\zeta_{2n}^3)^{n-1} \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
1 & \zeta_{2n}^{2n-1} & (\zeta_{2n}^{2n-1})^2 & \cdots & (\zeta_{2n}^{2n-1})^{n-1}
\end{pmatrix}$
</p>

<p>Then $\mathbf{p} &#x3D; V^{-1} \tilde{\mathbf{z}}$, which can be computed using FFT in $O(n \log n)$ time.</p>
<h3><span id="homomorphic-operations">Homomorphic Operations</span></h3><p>Once we have polynomials encoding our complex vectors, homomorphic operations correspond to:</p>
<ul>
<li><strong>Addition</strong>: $\text{Enc}(\mathbf{z}_1) + \text{Enc}(\mathbf{z}_2) &#x3D; \text{Enc}(\mathbf{z}_1 + \mathbf{z}_2)$</li>
<li><strong>Multiplication</strong>: $\text{Enc}(\mathbf{z}_1) \cdot \text{Enc}(\mathbf{z}_2) &#x3D; \text{Enc}(\mathbf{z}_1 \odot \mathbf{z}_2)$</li>
</ul>
<p>where $\odot$ is component-wise multiplication.</p>
<h2><span id="discrete-gaussian-distributions-and-noise">Discrete Gaussian Distributions and Noise</span></h2><p>Here’s where we get into the “why is this secure?” part. The whole security of Ring-LWE comes down to adding the right kind of <strong>noise</strong> to our encryptions.</p>
<h3><span id="the-noise-intuition">The Noise Intuition</span></h3><p>Think of noise in encryption like <strong>static on a radio</strong>. If you’re trying to eavesdrop on a radio transmission, a little bit of static makes it hard to understand, but the intended recipient (who knows what to listen for) can still decode the message.</p>
<p>But here’s the crucial insight: <strong>not all noise is created equal</strong>. Random uniform noise would work, but it turns out that <strong>Gaussian noise</strong> is optimal for lattice-based cryptography. Why? Because it plays nicely with the geometric structure of lattices.</p>
<h3><span id="discrete-gaussian-distribution-nature-s-favorite-noise">Discrete Gaussian Distribution: Nature’s Favorite Noise</span></h3><p>The discrete Gaussian distribution $D_{\mathbb{Z}, \sigma}$ is like a bell curve, but restricted to integers. Picture a normal distribution centered at 0, and then only keep the probability mass at integer points.</p>
<p>The parameter $\sigma$ controls the “width” of the bell curve:</p>
<ul>
<li>Small $\sigma$: Noise is concentrated near 0 (good for correctness, bad for security)</li>
<li>Large $\sigma$: Noise is spread out (good for security, bad for correctness)</li>
</ul>
<p>Mathematically: $\Pr[x] \approx \frac{1}{\sigma} \exp(-\pi x^2 &#x2F; \sigma^2)$</p>
<h3><span id="why-gaussian-the-geometric-intuition">Why Gaussian? The Geometric Intuition</span></h3><p>Here’s the deep reason why Gaussian noise is special: <strong>it’s the “most round” distribution</strong>. </p>
<p>When we add Gaussian noise to each coefficient of our polynomial, we’re essentially placing our secret in a “fuzzy cloud” that looks the same from every direction. This isotropy (rotational symmetry) is exactly what we need to make lattice problems hard.</p>
<p>If we used, say, uniform noise on ${-B, \ldots, B}$, our noise cloud would be cube-shaped, and cubes have corners where an attacker might find patterns. Gaussian clouds are perfectly round - no corners to exploit!</p>
<h3><span id="error-polynomial-sampling">Error Polynomial Sampling</span></h3><p>For Ring-LWE, we sample error polynomials $e(X) &#x3D; \sum_{i&#x3D;0}^{n-1} e_i X^i$ where each coefficient $e_i \leftarrow D_{\mathbb{Z}, \sigma}$ independently.</p>
<p>The <strong>norm</strong> of the error polynomial in the canonical embedding is:</p>
<p style="text-align:center;">
$\|\sigma(e)\|_{\infty} = \max_{i} |e(\zeta_{2n}^{2i+1})|$
</p>

<p>By concentration inequalities, with high probability:</p>
<p style="text-align:center;">
$\|\sigma(e)\|_{\infty} \leq \sigma \sqrt{n \log n}$
</p>

<p>This bound is crucial for correctness - we need the noise to be small enough that decryption works, but large enough for security.</p>
<h2><span id="security-foundations-ideal-lattices">Security Foundations: Ideal Lattices</span></h2><p>Now for the million-dollar question: <strong>why is Ring-LWE hard to break?</strong> The answer lies in geometry - specifically, the geometry of high-dimensional lattices.</p>
<h3><span id="the-lattice-intuition">The Lattice Intuition</span></h3><p>Think of a <strong>lattice</strong> as a regular arrangement of points in space, like the integer grid $\mathbb{Z}^2$ in the plane. But instead of 2D, we’re working in $n$-dimensional space where $n$ might be 1024 or 4096.</p>
<p>When we use Ring-LWE, we’re essentially <strong>hiding our secret in the lattice structure</strong>. The Ring-LWE samples give an adversary some information about which lattice we’re using, but not enough to reconstruct the secret.</p>
<h3><span id="from-polynomials-to-geometric-points">From Polynomials to Geometric Points</span></h3><p>Here’s the key connection: every polynomial $p(X) &#x3D; \sum p_i X^i$ corresponds to a point $(p_0, p_1, \ldots, p_{n-1})$ in $n$-dimensional space via the <strong>coefficient embedding</strong>.</p>
<p>The polynomial ring structure gives us a lattice with special properties - it’s not just any random lattice, but an <strong>ideal lattice</strong> with tons of symmetry. This extra structure is both a blessing (it makes things efficient) and potentially a curse (it might make attacks easier).</p>
<h3><span id="the-fundamental-lattice-problems">The Fundamental Lattice Problems</span></h3><p>Breaking Ring-LWE is equivalent to solving one of these problems on ideal lattices:</p>
<ol>
<li><strong>Shortest Vector Problem (SVP)</strong>: Given a lattice, find the shortest non-zero vector</li>
<li><strong>Closest Vector Problem (CVP)</strong>: Given a lattice and a target point, find the closest lattice point</li>
</ol>
<p>In 2D, these problems are easy - you can just look at the lattice and see the answer. But in 1024-dimensional space? Good luck! The number of lattice points to check grows exponentially with dimension.</p>
<h3><span id="worst-case-to-average-case-reduction">Worst-Case to Average-Case Reduction</span></h3><p>Here’s the beautiful part: Lyubashevsky, Peikert, and Regev showed that <strong>solving Ring-LWE on average is as hard as solving worst-case problems on ideal lattices</strong>.</p>
<p>Specifically, there’s a quantum reduction from:</p>
<ul>
<li><strong>Worst-case</strong>: $\gamma$-approximate Shortest Vector Problem (SVP) on ideal lattices in $\mathbb{Z}[X]&#x2F;(X^n + 1)$</li>
<li><strong>Average-case</strong>: Ring-LWE with Gaussian error width $\sigma &#x3D; \gamma \cdot \text{poly}(n)$</li>
</ul>
<p>This gives us confidence that Ring-LWE is hard even against quantum adversaries (though the reduction is quantum).</p>
<h3><span id="geometry-of-the-canonical-embedding">Geometry of the Canonical Embedding</span></h3><p>The canonical embedding $\sigma$ maps the ring to $\mathbb{C}^n$, but we can view this as $\mathbb{R}^{2n}$ by separating real and imaginary parts.</p>
<p>The key insight is that $\sigma$ is an <strong>isometry</strong> up to scaling: for any $p \in R$:</p>
<p style="text-align:center;">
$\|\sigma(p)\|_2^2 = n \cdot \|p\|_2^2$
</p>

<p>where $|p|<em>2^2 &#x3D; \sum</em>{i&#x3D;0}^{n-1} p_i^2$ is the coefficient norm.</p>
<p>This geometric structure is what makes lattice algorithms like LLL and BKZ work on ideal lattices.</p>
<h2><span id="parameter-selection-and-trade-offs">Parameter Selection and Trade-offs</span></h2><p>Choosing parameters for Ring-LWE schemes involves balancing security, correctness, and efficiency.</p>
<h3><span id="security-level">Security Level</span></h3><p>The security level depends on the <strong>root Hermite factor</strong> $\gamma$ of the best known lattice attacks. For $\lambda$-bit security, we need:</p>
<p style="text-align:center;">
$\gamma^{2n} \geq 2^{\lambda / 2}$
</p>

<p>Current estimates give $\gamma \approx 1.0045$ for BKZ attacks, so for 128-bit security:</p>
<p style="text-align:center;">
$n \geq \frac{\lambda}{2 \log_2(\gamma)} \approx \frac{128}{2 \cdot 0.0065} \approx 10000$
</p>

<p>But this is overly conservative. Practical parameter sets like those in Microsoft SEAL use $n \in {1024, 2048, 4096, 8192}$ with carefully chosen moduli.</p>
<h3><span id="modulus-selection">Modulus Selection</span></h3><p>The ciphertext modulus $q$ needs to be large enough to:</p>
<ol>
<li><strong>Avoid Modular Reduction Errors</strong>: $q &gt; \sigma \sqrt{n} \cdot 2^{\text{depth}}$</li>
<li><strong>Enable NTT</strong>: $q \equiv 1 \pmod{2n}$ for efficient polynomial multiplication</li>
<li><strong>Resist Attacks</strong>: Not too small relative to $n$</li>
</ol>
<p>A common approach is to use a <strong>product of primes</strong>: $q &#x3D; \prod_{i&#x3D;1}^k q_i$ where each $q_i \equiv 1 \pmod{2n}$.</p>
<h3><span id="noise-growth-analysis">Noise Growth Analysis</span></h3><p>In CKKS, after $d$ levels of multiplication, the noise magnitude grows roughly as:</p>
<p style="text-align:center;">
$\text{Noise} \approx \sigma \cdot n^{d/2} \cdot B^d$
</p>

<p>where $B$ is the bound on message coefficients. This exponential growth limits the multiplicative depth.</p>
<h2><span id="implementation-considerations">Implementation Considerations</span></h2><h3><span id="number-theoretic-transform">Number Theoretic Transform</span></h3><p>Polynomial multiplication in $\mathbb{Z}_q[X]&#x2F;(X^n + 1)$ can be done efficiently using NTT. For this to work, we need:</p>
<ol>
<li>$q \equiv 1 \pmod{2n}$</li>
<li>A primitive $2n$-th root of unity $\omega$ in $\mathbb{Z}_q$</li>
</ol>
<p>Then NTT is just FFT over $\mathbb{Z}_q$, giving us $O(n \log n)$ polynomial multiplication.</p>
<h3><span id="memory-and-bandwidth">Memory and Bandwidth</span></h3><p>Ciphertext size is a practical concern. A Ring-LWE ciphertext consists of two polynomials, so $2n \log q$ bits. For $n &#x3D; 4096$ and $\log q &#x3D; 200$, that’s about 200KB per ciphertext.</p>
<p>Techniques like <strong>ciphertext packing</strong> and <strong>batching</strong> help amortize this cost across multiple plaintexts.</p>
<h3><span id="precision-and-scaling">Precision and Scaling</span></h3><p>CKKS uses fixed-point arithmetic, so precision loss accumulates. The <strong>precision budget</strong> determines how many operations you can perform before precision becomes unacceptable.</p>
<p>After each multiplication, you typically need to <strong>rescale</strong> by dividing by some factor (and rounding), which reduces the ciphertext modulus but maintains precision.</p>
<p>The math here gets pretty involved, but basically you’re managing a trade-off between precision, noise, and remaining multiplicative depth.</p>
<h2><span id="looking-ahead">Looking Ahead</span></h2><p>This foundation sets us up perfectly for understanding more advanced topics like:</p>
<ul>
<li><strong>Automorphisms</strong>: How to rotate encrypted data using Galois theory</li>
<li><strong>Key Switching</strong>: Converting between different key representations</li>
<li><strong>Bootstrapping</strong>: Refreshing noise to enable unlimited computation</li>
<li><strong>Multi-Party Computation</strong>: Distributed computation on encrypted data</li>
</ul>
<p>The algebraic structure we’ve explored - cyclotomic rings, canonical embeddings, discrete Gaussians - forms the mathematical backbone of all these techniques.</p>
<p>I have to say, working through this math really drives home how elegant modern cryptography is. Like, the fact that we can pack complex numbers into polynomials, perform arithmetic homomorphically, and base security on lattice problems - it’s just beautiful mathematics serving practical ends.</p>
<p>In my next post, I’ll dive into automorphisms and key switching, building directly on these foundations. The Galois group action on cyclotomic rings gives us this incredible ability to rotate encrypted data, but it comes with the price of changing the encryption key. Key switching is the technique that lets us convert back to the original key, and the math behind it is pretty wild.</p>
<p>Anyway, hope this gives you a solid mathematical foundation for understanding modern FHE schemes. There’s obviously way more depth here - ideal lattices, algebraic number theory, concrete security analysis - but this should be enough to follow the more advanced techniques.</p>
<p>peace. da1729</p>
<h2><span id="references">References</span></h2><p>[1] Lyubashevsky, V., Peikert, C., &amp; Regev, O. (2010). On ideal lattices and learning with errors over rings. In Annual international conference on the theory and applications of cryptographic techniques (pp. 1-23). Springer.</p>
<p>[2] Cheon, J. H., Kim, A., Kim, M., &amp; Song, Y. (2017). Homomorphic encryption for arithmetic of approximate numbers. In International Conference on the Theory and Application of Cryptology and Information Security (pp. 409-437). Springer.</p>
<p>[3] Brakerski, Z., Gentry, C., &amp; Vaikuntanathan, V. (2012). (Leveled) fully homomorphic encryption without bootstrapping. In Proceedings of the 3rd Innovations in Theoretical Computer Science Conference (pp. 309-325).</p>
<p>[4] Regev, O. (2009). On lattices, learning with errors, random linear codes, and cryptography. Journal of the ACM, 56(6), 1-40.</p>
<p>[5] Peikert, C. (2016). A decade of lattice cryptography. Foundations and Trends in Theoretical Computer Science, 10(4), 283-424.</p>
<p>[6] Micciancio, D., &amp; Regev, O. (2009). Lattice-based cryptography. In Post-quantum cryptography (pp. 147-191). Springer.</p>
<p>[7] Smart, N. P., &amp; Vercauteren, F. (2014). Fully homomorphic SIMD operations. Designs, codes and cryptography, 71(1), 57-81.</p>
<p>[8] Halevi, S., &amp; Shoup, V. (2014). Algorithms in HElib. In Annual Cryptology Conference (pp. 554-571). Springer.</p>

    </div>
  </div>
</article>

<!-- Post Navigation -->

  <nav class="post-nav mt-2">
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
      
        <div class="widget">
          <div class="widget-title">Previous Post</div>
          <a href="/2025/09/14/AGI-running-on-Quantum-Chip/">AGI running on Quantum Chip?</a>
        </div>
      
      
      
        <div class="widget">
          <div class="widget-title">Next Post</div>
          <a href="/2025/07/03/Breaking-LWE-Encryption/">An Empirical Analysis of LWE Robustness Against Machine Learning Distinguishers</a>
        </div>
      
    </div>
  </nav>


<!-- Related Posts -->

        </main>
        
        <!-- Sidebar -->
        <aside class="sidebar">
          <!-- Sidebar Widgets -->

<!-- Recent Posts Widget -->

  <div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <ul>
      
        <li>
          <a href="/2025/10/08/Algebraic-Structures-in-FHE/">Algebraic Structures You’ll Keep Seeing in FHE (One-Stop Reference)</a>
          <div style="font-size: 0.8em; color: var(--text-secondary); margin-top: 4px;">
            Oct 8, 2025
          </div>
        </li>
      
        <li>
          <a href="/2025/09/27/Need-for-Gadget-Decomposition-in-LWE-Based-Cryptosystems/">Need for Gadget Decomposition in LWE Based Cryptosystems</a>
          <div style="font-size: 0.8em; color: var(--text-secondary); margin-top: 4px;">
            Sep 27, 2025
          </div>
        </li>
      
        <li>
          <a href="/2025/09/14/AGI-running-on-Quantum-Chip/">AGI running on Quantum Chip?</a>
          <div style="font-size: 0.8em; color: var(--text-secondary); margin-top: 4px;">
            Sep 14, 2025
          </div>
        </li>
      
        <li>
          <a href="/2025/08/15/Ring-LWE-and-CKKS-Mathematical-Foundations/">Ring-LWE and CKKS: Mathematical Foundations for Homomorphic Encryption</a>
          <div style="font-size: 0.8em; color: var(--text-secondary); margin-top: 4px;">
            Aug 15, 2025
          </div>
        </li>
      
        <li>
          <a href="/2025/07/03/Breaking-LWE-Encryption/">An Empirical Analysis of LWE Robustness Against Machine Learning Distinguishers</a>
          <div style="font-size: 0.8em; color: var(--text-secondary); margin-top: 4px;">
            Jul 3, 2025
          </div>
        </li>
      
    </ul>
  </div>


<!-- Categories Widget -->


<!-- Tags Widget -->

  <div class="widget">
    <h3 class="widget-title">Tags</h3>
    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
      
        <a href="/tags/AI-Acceleration/" class="tag">
          #AI - Acceleration
        </a>
      
        <a href="/tags/AI-Acceleration/" class="tag">
          #AI Acceleration
        </a>
      
        <a href="/tags/Abstract-Algebra/" class="tag">
          #Abstract Algebra
        </a>
      
        <a href="/tags/Analog/" class="tag">
          #Analog
        </a>
      
        <a href="/tags/Cryptanalysis/" class="tag">
          #Cryptanalysis
        </a>
      
        <a href="/tags/Cryptography/" class="tag">
          #Cryptography
        </a>
      
        <a href="/tags/Fully-Homomorphic-Encryption/" class="tag">
          #Fully Homomorphic Encryption
        </a>
      
        <a href="/tags/Hardware-Acceleration/" class="tag">
          #Hardware Acceleration
        </a>
      
        <a href="/tags/Lattices/" class="tag">
          #Lattices
        </a>
      
        <a href="/tags/Philosphy/" class="tag">
          #Philosphy
        </a>
      
        <a href="/tags/Post-Quantum-Cryptography/" class="tag">
          #Post Quantum Cryptography
        </a>
      
        <a href="/tags/Post-Quantum-Cryptography/" class="tag">
          #Post-Quantum Cryptography
        </a>
      
        <a href="/tags/Ring-Theory/" class="tag">
          #Ring Theory
        </a>
      
        <a href="/tags/VLSI/" class="tag">
          #VLSI
        </a>
      
    </div>
  </div>


<!-- Archive Widget -->

  <div class="widget">
    <h3 class="widget-title">Archive</h3>
    <ul>
      
      
        
          <li>
            <a href="/archives/2025/">
              October 2025 (1)
            </a>
          </li>
        
          <li>
            <a href="/archives/2025/">
              September 2025 (2)
            </a>
          </li>
        
          <li>
            <a href="/archives/2025/">
              August 2025 (1)
            </a>
          </li>
        
          <li>
            <a href="/archives/2025/">
              July 2025 (1)
            </a>
          </li>
        
          <li>
            <a href="/archives/2025/">
              April 2025 (2)
            </a>
          </li>
        
          <li>
            <a href="/archives/2025/">
              March 2025 (2)
            </a>
          </li>
        
      
    </ul>
  </div>


<!-- About Widget -->
<div class="widget">
  <h3 class="widget-title">About</h3>
  <p style="font-size: 0.9em; line-height: 1.6;">
    Welcome to my blog! Here I write about various topics including technology, programming, and more.
  </p>
  
  
    <div style="margin-top: 15px;">
      <strong style="font-size: 0.9em;">Find me on:</strong>
      <div style="margin-top: 8px; display: flex; flex-wrap: wrap; gap: 8px;">
        
          <a href="https://github.com/DA1729" class="tag" target="_blank" rel="noopener">
            github
          </a>
        
          <a href="https://x.com/sp0oky_daksh" class="tag" target="_blank" rel="noopener">
            twitter
          </a>
        
          <a href="mailto:dakshpandey177@gmail.com" class="tag" target="_blank" rel="noopener">
            email
          </a>
        
          <a href="https://sp0oky-portfolio.vercel.app/" class="tag" target="_blank" rel="noopener">
            portfolio
          </a>
        
      </div>
    </div>
  
  
  <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color);">
    <p style="font-size: 0.8em; color: var(--text-secondary); opacity: 0.8;">
      Theme designed with 
      <a href="https://claude.ai/code" target="_blank" rel="noopener" style="color: var(--link-color); text-decoration: none;">Claude Code</a>
    </p>
  </div>
</div>
        </aside>
      </div>
    </div>

    <!-- Footer -->
    <footer class="footer">
      <p>© 2025 Daksh Pandey. Portfolio-inspired theme crafted with Claude Code.</p>
    </footer>
  </div>

  <!-- JavaScript -->
  
<script src="/js/main.js"></script>

  
  <!-- Math Support -->
  
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          ignoreHtmlClass: 'tex2jax_ignore',
          processHtmlClass: 'tex2jax_process'
        }
      };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  
</body>
</html>